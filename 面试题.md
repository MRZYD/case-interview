### html

1. 前端性能优化

- 懒加载 打包配置 CDN 防抖节流 减少节流重绘

2. 回流重绘

- 回流：是指节点的几何信息发生修改，如宽高，位子。
- 重绘：是指节点的颜色，文字信息，阴影发生修改。

### css

1. 移动端适配 （媒体查询 响应式单位）

### js

#### 1. 深拷贝与浅拷贝

- 深拷贝和浅拷贝是只针对 Object 和 Array 这样的引用数据类型的。

![深拷贝与浅拷贝示意图](https://img-blog.csdnimg.cn/20210705182450571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODk1NjI4MA==,size_16,color_FFFFFF,t_70)

- 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

- ##### 浅拷贝的实现方式

  (1). Object.assign() | 扩展运算 [...] {...}

  Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。扩展操作符(…)使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制 ES6 的 symbols 属性。

  Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。

  ```js
  var obj = { a: { a: "kobe", b: 39 } };
  var initalObj = Object.assign({}, obj);
  initalObj.a.a = "wade";
  console.log(obj.a.a);
  //wade
  ```

  **_注意：当 object 只有一层的时候，是深拷贝_**

  ```js
  let obj = { username: "kobe" };
  let obj2 = Object.assign({}, obj);
  obj2.username = "wade";
  console.log(obj); //{username: "kobe"}
  ```

  (2). Array.prototype.concat()

  ```js
  let arr = [1, 3, { username: "kobe" }];
  let arr2 = arr.concat();
  arr2[2].username = "wade";
  console.log(arr);
  ```

  (3). Array.prototype.slice()

  ```js
  let arr = [1, 3, { username: " kobe" }];
  let arr3 = arr.slice();
  arr3[2].username = "wade";
  console.log(arr);
  ```

- ##### 深拷贝的实现方式

  (1). JSON.parse(JSON.stringify())

  ```js
  let arr = [1, 3, { username: " kobe" }];
  let arr4 = JSON.parse(JSON.stringify(arr));
  arr4[2].username = "duncan";
  console.log(arr, arr4);
  ```

  - 原理： 用 JSON.stringify 将对象转成 JSON 字符串，再用 JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。

  **_这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。_**

  ```js
  let arr = [1, 3, { username: " kobe" }, function () {}];
  let arr4 = JSON.parse(JSON.stringify(arr));
  arr4[2].username = "duncan";
  console.log(arr, arr4);
  ```

  - 这是因为 JSON.stringify() 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串，不能接受函数。

  (2). 手写递归方法

  - 递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝

  ```js
  //定义检测数据类型的功能函数

  function checkedType(target) {
    return Object.prototype.toString.call(target).slice(8, -1);
  }

  //实现深度克隆---对象/数组

  function clone(target) {
    //判断拷贝的数据类型

    //初始化变量result 成为最终克隆的数据

    let result,
      targetType = checkedType(target);

    if (targetType === "Object") {
      result = {};
    } else if (targetType === "Array") {
      result = [];
    } else {
      return target;
    }

    //遍历目标数据
    for (let i in target) {
      //获取遍历数据结构的每一项值，注意这里的i不一定是数组下标，如果target是对象的话那么i就是key值
      let value = target[i];
      //判断目标结构里的每一值是否存在对象/数组
      if (checkedType(value) === "Object" || checkedType(value) === "Array") {
        //对象/数组里嵌套了对象/数组
        //继续遍历获取到value值
        result[i] = clone(value);
      } else {
        //获取到value值是基本的数据类型或者是函数。
        result[i] = value;
      }
    }
    return result;
  }
  ```

  (3) 函数库 lodash

  - 该函数库也有提供 \_.cloneDeep 用来做 Deep Copy。

  ```js
  var _ = require("lodash");
  var obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3] };
  var obj2 = _.cloneDeep(obj1);
  console.log(obj1.b.f === obj2.b.f);
  // false
  ```

#### 2. 数组去重

- 数组去重 https://blog.csdn.net/Lguorong/article/details/124301325

#### 3. 数组中的元素是对象的话如何去重

    - 双层for循环

      两两比较，如果后一个对象的id值和前一个对象的id值相等，就把后面的对象删除

    - indexOf()

      定义一个数组存储id的值,然后逐个比较,把id值重复的对象删除即可

    - 对象访问属性的方法

      采用对象访问属性的方法，判断属性值是否存在

    - Map()

      has方法可以判断Map对象中是否存在指定元素,有则返回true，否则返回false

      set方法可以向Map对象添加新元素 map.set(key, value)

      values方法可以返回Map对象值的遍历器对象

    ```js
    let arrObj = [
      { name: "小红", id: 1 },
      { name: "小橙", id: 1 },
      { name: "小黄", id: 4 },
      { name: "小绿", id: 3 },
      { name: "小青", id: 1 },
      { name: "小蓝", id: 4 }
    ];

    // 双层for循环
    function fn1(tempArr) {
      for (let i = 0; i < tempArr.length; i++) {
        for (let j = i + 1; j < tempArr.length; j++) {
          if (tempArr[i].id == tempArr[j].id) {
            tempArr.splice(j, 1);
            j--;
          };
        };
      };
      return tempArr;
    };
    console.log(fn1(arrObj));

    // indexOf()
    function fn2(tempArr) {
      let newArr = [];
      for (let i = 0; i < tempArr.length; i++) {
        if (newArr.indexOf(tempArr[i].id) == -1) {
          newArr.push(tempArr[i].id);
        } else {
          tempArr.splice(i, 1);
        };
      };
      return tempArr;
    };
    console.log(fn2(arrObj));

    // 对象访问属性的方法
    function fn3(tempArr) {
      let result = [];
      let obj = {};
      for (let i = 0; i < tempArr.length; i++) {
        if (!obj[tempArr[i].id]) {
          result.push(tempArr[i]);
          obj[tempArr[i].id] = true;
        };
      };
      return result;
    };
    console.log(fn3(arrObj));

    // Map()
    let map = new Map();
    for (let item of arrObj) {
      if (!map.has(item.id)) {
        map.set(item.id, item);
      };
    };
    arr = [...map.values()];
    console.log(arr);
    ```

#### 4. 基本数据类型有哪些

    Boolean、Number、String、null、undefiend、Symbol

#### 5. 引用类型有哪些

Object、Array、Function、其他内置：Date、自定义类型：class

#### 6. 引用类型和数据类型，两者存储方式有哪些区别

- 基本数据类型的特点：直接存储在栈(stack)中的数据

- 引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里

#### 7. 什么是循环引用

- JavaScript 中的循环引用是指两个或多个对象之间相互引用的情况。这种情况下，这些对象就不能被垃圾回收机制正常回收，会导致内存泄漏。

- 循环引用通常发生在对象之间相互包含或相互依赖的情况。比如，A 对象中有一个指向 B 对象的引用，而 B 对象中又有一个指向 A 对象的引用，这样就形成了一个循环引用。

- 在 JavaScript 中，循环引用问题是一个常见问题，常见的解决方法有使用 WeakMap 和 WeakSet，使用计数器，使用双向链表，避免循环引用等。

- https://www.cnblogs.com/yuzhihui/p/17064433.html

#### 8. 怎么判断循环引用

- 定义了引用类型的变量后该变量存的是堆内存的地址，通过地址访问堆内存的数据，从而产生了引用。而基本数据类型定义后存储的是数据值，不需要引用
- 在 js 中对两个引用类型使用 === 判断是对两者的地址进行判断
- 所以判断是否存在循环引用，可以简单定义为对象内部的属性是否和对象本身的地址相同

#### 9. 如何处理循环引用

- 去除对象中涉及到的循环引用的属性.消除循环引用 JSON.decycle 方法可以解除循环

```js
{"a":{"b":{"$ref":"$"}}}
```

- 将循环引用中的一个对象缓存起来，以避免重复序列化或者创建

```js
1 .WeakMap来记录对象是否被克隆,主要考虑一下三点。
2 .WeakMap对象是key=>value形式，不会重复记录
3 .WeakMap是弱引用，如果不在使用，空间会直接释放
4 .WeakSet 与 WeakMap 类似，它存储的元素也是弱引用，不会影响到对象的存活状态。
```

#### 10. 对闭包的理解

本质是一个对象被内部函数引用着,通过 chrome debugger 调试工具查看

- ##### 产生:

  - 外部函数声明嵌套内部函数且引用了外部函数的变量,调用外部函数创建了内部函数

    ##### 使用

  - 外部函数 return 内部函数,然后调用内部函数

    ##### 释放

  - 将指向外部函数的变量赋值为 null 释放闭包

- ##### 作用

  - 延长局部变量的生命周期避免调用后内存释放,外部函数断开引用被垃圾回收
  - 提供功能外部使用但不想让其看到我内部实现的逻辑
  - 外部可以反复操作局部变量(内部函数 return 变量)

- ##### 应用

  - 匿名函数自调用

  - 函数柯里化

  - 模块化编译时会给模块代码包裹一层匿名函数自调用,并 return 一个对象暴露出去

#### 11. 事件 event 的理解

- JavaScript event 即为事件，开发人员在代码中使用事件处理器（event handlers）来监听使用者的行为（Events），通常 Event 会通过某特定函数来执行特定动作，浏览器内置的 JavaScript 核心会判断使用者发生哪些动作，如 click 动作（对应 onclick event 负责监听）、改变表单中的某个文本框（对应 onchange event 负责监听）、鼠标移滑动（对应 onmouseover 负责监听）等等，一旦监听到到使用者发生的动作，就能够触发特定 function 执行，这就是 JavaScript event 事件。

##### 总结

- Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。

#### 12. 捕获和冒泡的先后顺序以及什么两者区别

##### 冒泡（由下到上）

- 意思就是说，假如用户单击了一个元素，该元素拥有一个 click 事件，那么同样的事件也将会被它的祖先触发，这个事件从该元素开始一直冒泡到 DOM 树的最上层，这一过程称为事件冒泡。
  ![事件冒泡](https://img-blog.csdnimg.cn/bdd42c51e4f44ed3a3bca0e12790ff9c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aG65YW26Ieq54S2fg==,size_17,color_FFFFFF,t_70,g_se,x_16)

##### 捕获（由上到下）

- 事件捕获和事件冒泡是相反的，也就是说，当用户触发了一个事件的时候，这个事件是从 DOM 树的最上层开始触发一直到捕获到事件源。

##### 总结

- 事件捕获是指：从外到内寻找目标节点的过程。
- 事件冒泡是指：从目标节点向外进行事件发散。

#### 13. 事件委托

- 事件委托的原理：是通过子元素事件冒泡，在父元素中能通过自定义事件，捕获到子元素的事件发散，从而触发自定义方法，这样做的好处是，可以减少内存的消耗。

#### 14. Promise

- promise 是一个对异步操作进行封装并返回其结果的构造函数.

- 使代码更加简洁和避免回调地狱。

- promise 是浏览器引擎自带的（但不是所有浏览器都支持 promise）

- new Promise 函数是同步函数,并且是立即执行的。

- promise 共有三种状态，pending,fulfilled,rejected

- 状态只能从 pending 变为 fulfilled 状态，成功状态。或者从 pending 变为 rejected 状态，失败状态。

- promise 只有这两种转变状态，是转变状态哈。在无其他状态。

- 当你 new 一个 promise 时，就已经开始自动执行函数。promise 是同步的，但 then 是异步的，要注意区分。

Promise 详细内容 https://blog.csdn.net/qq_31676483/article/details/123189691

#### 15. 原型链

- 通过对象的** proto **隐式原型属性连接所有对象,从而在查找对象属性时:先在自身找,找不到通过隐式原型链往上找直到 undefined
- 所有构造函数都是 Function 的实例对象包括自己:Function.prototype===Function.\_proto 和 Fn.\_\_proto === Function.prototype
- 构造函数的 prototype 显式原型属性,只在构建实例对象时赋值给实例对象的\_* proto *隐式原型属性,并利用 constructor 属性指回构造函数
- 所有对象都是 Object 的实例所以所有实例对象的 proto 都指向 Object.prototype,隐式原型链的尽头:Object.prototype=Object.prototype.proto\_=null

##### JS 引擎解析代码前:

- JS 引擎在解析代码前先执行内置代码定义出内置的构造函数或类型对象:Function/Object/Array/String/Reg/Date/Math 等
- Function.prototype 时一个函数不为对象非 Object 所构造,所以 JS 引擎内置强绑使其加入隐式原型链,从而:Function instanceof Object 为 true

```js
//JS引擎内部两段伪代码
Function.prototype.__proto__ = Object.prototype;
Object.prototype.__proto__ = null;
```

#### 16. 跨域

- 什么是跨域，不符合同源策略就是跨域，协议+域名+端口。

- 解决跨域的方法：

  - jsonp 原理：script 标签引入 js 文件不受跨域影响。不仅如此，带 src 属性的标签都不受同源策略的影响。正是基于这个特性，我们通过 script 标签的 src 属性加载资源，数据放在 src 属性指向的服务器上，使用 json 格式。

  - document.domain + iframe 跨域 这种情况只适用于主域相同，子域不同的应用场景。实现原理：两个页面都通过 js 设置 document.domain 为基础主域，就实现了同域，就可以互相操作资源了。

  - 跨域资源共享（CORS） 只要在服务端设置 Access-Control-Allow-Origin 就可以实现跨域请求，若是 cookie 请求，前后端都需要设置。由于同源策略的限制，所读取的 cookie 为跨域请求接口所在域的 cookie，并非当前页的 cookie。

  - nginx 反向代理

  - WebSocket 协议跨域 WebSocket 协议是 HTML5 的新协议。能够实现浏览器与服务器全双工通信，同时允许跨域，是服务端推送技术的一种很好的实现。

#### 17. 正向代理与反向代理

- 正向代理主要是为了通过代理去访问一些无法访问的资源。此时代理服务器对外就表现为一个客户端。

- 反向代理主要是为了将请求分发给内部的服务器。此时代理服务器对外就表现为一个服务器。(请求转发)

##### 区别

    - 1、是否需要手动设置代理服务器IP。

      - 正向代理需要我们手动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取资源。反向代理不需要你做任何设置，直接访问服务器真实ip或者域名。但是服务器内部会根据url来对请求分发到指定的服务器。

    - 2、客户端和服务器的不可见性。

      - 正向代理是代理客户端，为客户端收发请求，使得真实客户端对服务器不可见。

      - 反向代理是代理服务器端，为服务器收发请求，使得真实服务器对客户端不可见。

- 正向代理与反向代理区别 https://segmentfault.com/a/1190000021218912?sort=newest

#### 18. 事件循环

- ##### 在了解事件循环前，需要一些有关 JS 特性的前置知识。

  - JS 引擎是单线程的，直白来说就是一个时间点下 JS 引擎只能去做一件事情，而 Java 这种多线程语言，可以同时做几件事情。

  - JS 做的任务分为同步和异步两种，所谓 “异步”，简单说就是一个任务不是连续完成的，先执行第一段，等做好了准备，再回过头执行第二段，第二段也被叫做回调；同步则是连贯完成的。

  像读取文件、网络请求这种任务属于异步任务：花费时间很长，但中间的操作不需要 JS 引擎自己完成，它只用等别人准备好了，把数据给他，他再继续执行回调部分。

  如果没有特殊处理，JS 引擎在执行异步任务时，应该是存在等待的，不去做任何其他事情。在执行异步任务时有大量的空闲时间被浪费。

  实际上这是大多数多线程语言的处理办法。但对于 JS 这种单线程语言来说，这种长时间的空闲等待是不可接受的：遇到其他紧急任务，Java 可以再开一个线程去处理，JS 却只能忙等。

  - 所以采取了以下的“异步任务回调通知”模式：

  在等待异步任务准备的同时，JS 引擎去执行其他同步任务，等到异步任务准备好了，再去执行回调。这种模式的优势显而易见，完成相同的任务，花费的时间大大减少，这种方式也被叫做非阻塞式。

  而实现这个“通知”的，正是事件循环，把异步任务的回调部分交给事件循环，等时机合适交还给 JS 线程执行。事件循环并不是 JavaScript 首创的，它是计算机的一种运行机制。

  ##### 事件循环是由一个队列组成的，异步任务的回调遵循先进先出，在 JS 引擎空闲时会一轮一轮地被取出，所以被叫做循环。

  根据队列中任务的不同，分为宏任务和微任务

  详细内容：https://blog.csdn.net/weixin_47450807/article/details/123131474

#### 19. 宏任务与微任务

- 事件循环由宏任务和在执行宏任务期间产生的所有微任务组成。完成当下的宏任务后，会立刻执行所有在此期间入队的微任务。

- 这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。

- 常见的宏任务有：script（整体代码）/setTimout/setInterval/setImmediate(node 独有)/requestAnimationFrame(浏览器独有)/IO/UI render（浏览器独有）

- 常见的微任务有：process.nextTick(node 独有)/Promise.then()/Object.observe/MutationObserver

- 执行流程

  - 1、首先先执行主程序中的代码

  - 2、然后在执行宏任务队列的代码之前，要先看看微任务队列中是否为空，如果不为空，则将微任务队列中的任务取出执行。

  - 3、在执行宏任务之前，保证微任务队列中的任务为空。

浏览器的事件循环由一个宏任务队列+多个微任务队列组成。

首先，执行第一个宏任务：全局 Script 脚本。产生的的宏任务和微任务进入各自的队列中。执行完 Script 后，把当前的微任务队列清空。完成一次事件循环。

接着再取出一个宏任务，同样把在此期间产生的回调入队。再把当前的微任务队列清空。以此往复。

宏任务队列只有一个，而每一个宏任务都有一个自己的微任务队列，每轮循环都是由一个宏任务+多个微任务组成。

详细内容：https://blog.csdn.net/weixin_45730243/article/details/125673846

#### 20. ES6 新特性

- 变量声明：

```js
const声明常量 在声明时必须被赋值，声明了值就不能被修改了， 但是如果声明的是对象，只要引用地址没变就行。
let声明变量 关键词声明的变量不具备变量提升特性。
```

- 模板字符串

```js
基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定；
ES6反引号(``)直接搞定；
```

- 箭头函数

```js
ES6 中，箭头函数就是函数的一种简写形式()=>{}
不需要 function 关键字来创建函数
省略 return 关键字
继承当前上下文的 this 关键字
```

- 展开操作符 (…) 用法比较多，常用于解构。
- for…of 和 for…in
- Proxy 代理，vue3 的核心
- Promise 构造函数 用于解决 回调地狱
- async / await

#### 21. js 类型判断

- undefined 和 null

  === :用于判断 undefined 和 null

- 基本数据

  (1) typeof() : 返回类型小写,null 对象数组等所有非函数对象都返回 object

  (2) A instanceof Array :返回 true/false 判断 A 原型链上对象是否为 B 类型的实例 ,比如 typeof 无法区分数组和对象

  (3) []/{}.constructor :得到对象类型的构造函数和 Number/Boolean/String 的包装类型的构造函数(null/undefined 没有包装类型)

- 引用类型

  (1) Array.isArray([]) : 专门用来判断数组

  (2) String.prototype.toString.call({}) : 为了让任意对象都能调用 Object 原型上的 toString 方法,需要利用 call 进行 toString 重写,返回"[object 类型名称]"字符串然后 slice 截取

#### 22. Javascript 中的 CJS、AMD、UMD 、ESM 是什么

- (1). CJS

  cjs 是 commonds 的缩写。主要用于服务器端，主要使用如下：

  ```js
    // 导出
    const obj = {a: 1);
    module.exports = obj;

    // 引入
    const obj = require('"/test.js");
  ```

- (2). ESM

  ESM 是 ESModlule.是 ECMASCript 自己的模块体系，是 Javascript 提出的实现一个标准模块系统的方案，于 ES6 引 1 入，代表 ES 模块。主要使用如下：

  ```js
  //导出 : export 命令
  export const obj = (name: 'E1e");

  // 默认导出 export default 命令
  export default (name: 'E1e');

  // 引入接口：import命令
  // 引入普通导出

  import ( obj ) from './test.js';

  // 引入默认导出
  import obj from './test.js';

  // 可以在HTML 中调用，只要如下

  <script type="module">
    import {func1} from 'my-lib";
    func1();
  </script>
  ```

  - 它具有两方面优点：具有 CJS 的简单语法 和 AMD 的异步

- (3). AMD

  AMD 代表异步模块定义

  AMD 是异步(asynchronously)导入模块的(因此得名）

  一开始被提议的时候，AMD 是为前端而做的(而 CJS 是后端）

  AMD 的语法不如 CJS 直观。我认为 AMD 和 CJS 完全相反

- (4). UMD

  UMD 代表通用模块定义 (Universal Module Definition)

  在前端和后端都适用（通用”因此得名）

  与 CS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。

  当使用 RollupWebpack 之类的打包器时，UMD 通常用作备用模块

#### 23. Javascript 中的 CJS、ESM 的区别是什么

- 使用方式不同

  - CJS 不能在浏览器中工作。它必须经过转换和打包
  - commonds 是被加载的时候运行，esModule 是编译的时候运行
  - commonJs 输出的是值的浅拷贝，esModule 输出值的引用
  - commentJs 具有缓存。在第一次被加载时，会完整运行整个文件并输出一个对象，拷贝(浅拷贝）在内存中。下次加载文件时，直接从内存中取值
  - commonJs 输出值拷贝，esModule 输出值引用

- 引用：

  require 和 import 都可引用

- ES6 模块加载 CommonJS 模块

  module.exports 等同于 export default 可以用 import 引入

- CommonJS 模块加载 ES6 模块

  不能使用 require 命令，是要使用 import 函数。

- exports 和 module.exports 的区别

  module.exports 默认值为{}

  exports 是 module.exports 的引用

  exports 默认指向 module.exports 的内存空间

  require() 返回的是 module.exports 而不是 exports

  若对 exports 重新赋值，则断开了 exports 对 module.exports 的指向

详细介绍：https://blog.csdn.net/q515656712/article/details/128643317

#### 24. 防抖节流函数手写

- 防抖

  简单的理解方式就是：用户多次触发事件，在用户一直触发事件中，事件不会执行.

  只有在用户停止触发事件一段时间之后再执行这个事件一次。

```js
function debounce(fn, ms) {
  let timeout = null;
  return function () {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    }, ms);
  };
}
```

- 节流

  简单的理解方式就是：用户多次触发事件，在用户一直触发事件过程中事件会每间隔一段时间执行一次会执行多次。

```js
function throttle(fn, ms) {
  let flag = true;
  return function () {
    if (!flag) return;
    flag = false;
    setTimeout(() => {
      fn.apply(this, arguments);
      flag = true;
    }, ms);
  };
}
```

#### 25. 构造函数、回调函数、箭头函数

- 构造函数：在 JavaScript 中，用 new 关键字来调用的函数，称为构造函数，构造函数首字母一般大写

```js
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}

var p1 = new Person("Tom", "18", "男");
var p2 = new Person("Jerry", "18", "男");
```

- 回调函数：被作为实参传入另一函数，并在该外部函数内被调用，用来完成某些任务的函数，称为回调函数

```js
function greeting(name) {
  alert("hello" + name);
}

function processUserInput(callback) {
  var name = prompt("请输入你的名字");
  callback(name);
}

processUserInput(greeting);
```

- 箭头函数：ES6 中，箭头函数就是函数的一种简写形式()=>{}，不需要 function 关键字来创建函数，省略 return 关键字，继承当前上下文的 this 关键字

```js
// 普通函数
let sum = function (a, b) {
  return a + b;
};

// 箭头函数
let sum1 = (a, b) => {
  return a + b;
};
```

#### 26. 作用域

- ##### 分类

  - 全局 / 函数 / 块(if/for/while) / 词法/静态作用域:是 JS 在编写时就确定的规则
  - 对象本身不产生作用域
  - const/let/class 不会添加为 window 的属性

- ##### 作用域链(全局/函数变量对象组成的数组)

  - 用于多个嵌套结构由内向外查找变量
  - 浏览器引擎解析时确定
  - 本质是一个数组里边放由内向外调用函数产生的变量对象,对象用于存储局部变量

- ##### 变量提升

  - 执行全局代码和函数时会进行"预解析",将 var 和 function 声明放到最前边,(let/const/class)以及函数表达式没有提升
  - 表达式: 会返回一个可使用的数据值,没有分号不能独立存在: 3/""/true/{}/[]/变量/匿名函数/函数调用 和 变量与值运算/判断

- ##### this 指向(运行时动态绑定的)

  - 默认绑定:直接调用 fn() 默认为 window/严格模式下 undefined,严格模式下声明变量不能省略 var,且 this 指向 window

  - 隐式绑定:obj.fn()

  - 显式绑定:fn.call/apply/bind(this 指向的对象)

  - 构造函数绑定:通过 new fn()的构造出来的实例对象

  - 特殊情况

    - 箭头函数没有自己的 this,this 是一个内置的变量所以会通过作用域链指向外部作用域
    - 回调函数
      - 定时器/ajax/promise/数组带遍历的方法 =>window/undefined
      - vue 控制的回调函数=>该组件实例对象
      - react 控制的周期回调=>组件实例对象 / 事件监听回调=>undefined

  - ##### 改变 this 指向

    - ES6 之后用箭头函数,之前在外部 that=this 然后通过作用域链用 that
    - fn.call()/apply(this 对象):改变函数的 this 指向并立即调用 fn,fn.bind()只修改 this 指向并返回 fn 函数

### Ts

1. 用过泛型吗，泛型是什么

- 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性

- 泛型 T 作用域只限于函数内部使用

2. 泛型里面定义一个局部泛型

### Vue2

#### 1. vue-router 解决什么问题，两种模式：什么场景下使用

- ##### 前端路由存在的意义

  前端路由主要应用在 spa 项目中。

  核心---在无刷新（不向后端发送请求）的情况下，可以根据不同 url 更改视图。

- ##### 浏览器提供 hash 和 history 两种模式支持（可以说，hash 模式和 history 模式都属于浏览器自身的特性），Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由

  - hash：

    比如这个 URL：http://www.abc.com/#/hello，hashURL模式中#后面的就是hash值，当hash值发生变化时，
    可以通过 hashChange 事件监听到 url 的变化，从而进行页面跳转。每一次改变#后的部分，都会在浏览器的访问历史中
    增加一个记录，使用“后退”按钮，就可以回到上一个位置。

    注意：无论 hash 值如何变化，服务器接收到的 HTTP 请求中 url 永远是#前面的http://www.abc.com；对后端完全没有
    影响，因此改变 hash 不会重新加载页面。

  - history：

    是 HTML5 新推出的功能。主要使用 history.pushState() 和 history.replaceState() 方法。同时还有一个新的
    popState 事件（当用户做出浏览器动作，例如点击“前进”、“后退”按钮时，触发 popState 事件），通过监听这一事件，
    配合上面这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，提供了对当前浏览
    器进行修改的功能，实现改变了当前的 URL，但浏览器不会立即向后端发送请求。

    注意：history 模式更改 url 不会向后端发送请求，但是如果点击刷新，就会向后端发送请求。

- ##### 两种模式的区别

  - 1.history 模式可以通过 api 设置任意的同源 url，hash 模式只可以更改#后的内容；
  - 2.history 模式可以通过 api 添加任意类型的数据到历史记录中，hash 模式只能更改 hash 值，也就是字符串；
  - 3.history 模式设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；

    hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；

  - 4.hash 模式无需后端配置，且兼容性好。

    history 模式在用户手动输入 url 地址或刷新页面时会发起 url 请求，前端的 URL 必须和实际向后端发起请求的 URL 一
    致，如 http://www.abc.com/book/id。如果后端缺少对 /book/id 的路由处理，将返回 404 错误。后端需要配置
    index.html 页面用于匹配不到静态资源的时候，同时在前端处理 404。

  - 5.history 模式可额外设置 title 属性供后续使用。

- ##### 使用场景 （ Vue-router 官网 ）

  - 一般场景下，hash 和 history 都可以，除非你更在意颜值，# 符号夹杂在 URL 里看起来确实有些不太美丽。
  - 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。

总结：结合自身例子，对于一般的 Vue + Vue-Router + Webpack + XXX 形式的 Web 开发场景，用 history 模式即可，只需在后端（Apache 或 Nginx）进行简单的路由配置，同时搭配前端路由的 404 页面支持。

#### 2. vuex 介绍，如何实现持久性

- ##### Vuex 的定义

  官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。通俗点讲可以想象为一个“前端数据库”（数据仓库），管理前端项目变量。

- ##### Vuex 的作用：

  Vuex 的作用可以防止变量名重复，管理变量。

- ##### Vuex 的能够解决的问题：

  - 1）多个视图依赖于同一状态

  - 2）来自不同视图的行为需要变更同一状态

- ##### vuex 构造函数 传参对象

  - state： 统一定义公共数据（类似于 data(){return {a:1, b:2，xxxxxx}}）
  - getters： 类似于 computed(计算属性，对现有的状态进行计算得到新的数据-------派生 )
  - mutations ： 使用它来修改数据(类似于 methods)更改 state 中的数据必须使用 mutations 来进行更改
  - actions： 发起异步请求
  - modules： 模块拆分

- ##### action 和 mutation 区别

  - mutations 中的方法可以直接修改 state 数据，actions 是异步执行 mutations 中的方法，所以它俩都可以改数据，区别是一个是同步一个是异步。
  - 流程顺序

    “相应视图—>修改 State”拆分成两部分，视图触发 Action，Action 再触发 Mutation。

  - 角色定位

    基于流程顺序，二者扮演不同的角色。

    Mutation：专注于修改 State，理论上是修改 State 的唯一途径。

    Action：异步请求。

  - 限制

    - Mutation：

    必须同步执行。使用 this.$store.commit 来提交 mutation 对 store 中的状态进行修改。

    - Action：

    提交的是 mutation，而不是直接变更状态 (非状态！！！)，

    可以异步，但不能直接操作 State。使用 this.$store.dispatch 来提交

- ##### 数据持久化

  - 1）利用浏览器的本地存储 localStorage 和 sessionStorage

    vuex 的 state 在 localStorage 或 sessionStorage 取值

    在 mutations 里面，定义的方法对 vuex 的状态操作的同时，对存储也做对应的操作

  - 2）利用 vue-presistedstate 插件
    原理和方法 1 一样，也是结合了浏览器的本地存储 localStorage 和 sessionStorage，只不过是统一的配置，不需要每次都手写存储方法。
    安装方式；npm install vuex-persistedstate --save
    引入：在 store 下的 index.js 中引入，然后使用插件 plugins

#### 3. axios 是什么，怎么用，多个异步请求如何变同步

- ##### 什么是 axios？

  Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。

- ##### axios 的使用

  - 引用 js 的两种方式：

    - 在线引用：<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

    - 本地引用：访问https://unpkg.com/axios/dist/axios.min.js 另存为 axios.min.js

- ##### 案例

  - axios 的 get 请求的两种方式

    - 方式一： URL 参数拼接方式

      ```js
        var baseURL = "http://localhost:8080"
        axios.get(baseURL + '/user?ID=12345')
        .then(res => {
            console.log(res);
        })；
      ```

    - 方式二： params:{param1:value1 ,param2: value2 } 方式

      ```js
        var baseURL = "http://localhost:8080"
        var url = baseUrl + "/user/login"
        axios.get(url, {
          params: {
            username: vm.username,
              password: vm.password
          }
        }).then(res => {
          console.log(res);
        }
      ```

  - axios 的 post 请求

  ```js
  var baseURL = "http://localhost:8080";
  var url = baseUrl + "/user/regist";
  axios
    .post(url, {
      username: "zhangsan",
      password: "123456",
    })
    .then((res) => {
      console.log(res);
    });
  ```

- ##### 多个异步如何变成同步

  在用 ajax 方法请求后端接口时，可以通过修改 async 的值来改变异步/同步。结合这个思路以及网络资料，虽然在 axios 方法中没有类似属性值，但可以通过 async+await 组合使用将异步执行该为同步执行。

  ```js
    //index.vue
    methods: {
      async getInfo() {//请求接口并对返回数据做处理
        await api.get().then( response => {//api.get()

        })
      },
      async f(){
        console.log("调用接口...")
        await this.getInfo()
        console.log("接口调用完成...")
      }
    }
  ```

#### 4. watch 监听如何实现，与 compouted 区别

- ##### watch 使用的几种方法

  - 1、 通过 watch 监听 msg 数据的变化。

    ```js
      watch: {
        msg(oldValue, newValue) {
          console.log(oldValue)
          console.log(newValue)
        }
      }
    ```

  - 2、通过 watch 监听 obj 数据的变化。（深度监听 deep）

    ```js
      data（） {
        return {
          obj: {
            'name': "赵",
            'age': 18
          },
        }
      },
      watch: {
        obj: {
          handler(oldValue,newVal) {
            console.log(oldValue)
            console.log(newValue)
          },
          deep: true  // 深度监听
        }
      }
    ```

    - 3.通过 watch 监听 data 数据的变化，数据发生变化时,执行 change 方法
      ```js
        watch: {
          data： 'change' // 值可以为methods的方法名
        }，
        methods: {
          change(oldVal,newVal){
            console.log(oldVal,newVal)
          }
        }
      ```

- ##### watch 中的 immediate 与 handler 和 deep 属性

  - 1、immediate 属性

    使用 watch 时有一个特点，就是当值第一次绑定时，不会执行监听函数，只有值发生改变时才会执行。如果我们需要在最初绑定值的时候也执行函数，则就需要用到 immediate 属性。

  - 2、handler 属性

    watch 中需要具体执行的方法

  - 3、deep 属性

    当需要监听一个对象的改变时，普通的 watch 方法无法监听到对象内部属性的改变，此时就需要 deep 属性对对象进行深度监听，数组字符串一般不需要

- ##### watch 与 computed 的区别

  - 1）功能上：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。

  - 2）是否调用缓存：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调。

  - 3）是否调用 return：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return。

  - 4）computed 默认第一次加载的时候就开始监听；watch 默认第一次加载不做监听，如果需要第一次加载做监听，添加 immediate 属性，设置为 true（immediate:true）

  - 5）使用场景：computed----当一个属性受多个属性影响的时候，使用 computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用 watch-----搜索框.

#### 5. 数据响应式与双向数据绑定原理区分

数据响应式是 Vue 的核心特性之一，而双向数据绑定是通过指令或修饰符实现的一种特性

- ##### 1）数据响应式原理

  通过 数据劫持结合发布者-订阅者模式 的方式来实现的（在数据变动时发布消息给订阅者，触发相应的监听回调）

  Vue 内部通过 Object.defineProperty() 监听对象属性的改变，它有对应的两个描述属性 get 和 set，当数据发生改变后，通过此方法对两个属性进行重写操作，从而通过发布订阅者模式通知界面发生改变。

  Vue2.x 是借助 Object.defineProperty() 实现的，而 Vue3.x 是借助 Proxy 实现的，通过 Proxy 对象创建一个对象的代理，并且 Proxy 的监听是深层次的，监听整个对象，而不是某个属性。

  下面以一个简单的图来描述发布者-订阅者模式：

  ![img](https://img-blog.csdnimg.cn/c57e1ff1356843a09896911212f9a39c.png)

  - new Vue() 首先执行初始化，对 data 执行响应化处理，这个过程发生在 Observe 中
  - 同时对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图，这个过程发生在 Compile 中
  - 由于 data 的某个 key 在一个视图中可能出现多次，所以每个 key 都需要一个管家 Dep 来管理多个 Watcher
  - 同时定义一个更新函数和 Watcher，将来对应数据变化时 Watcher 会调用更新函数
  - 将来 data 中数据一旦发生变化，会首先找到对应的 Dep，通知所有的 Watcher 执行更新函数，然后更新视图

- ##### 2) 双向数据绑定原理

  双向数据绑定可以通过指令 v-model 和修饰符 .sync 两种方式实现，像在组件中使用 v-model 绑定监听表单的变化，就属于双向绑定

  双向数据绑定由三个重要部分构成：

  - 数据层（Model）: 页面渲染所需要的数据
  - 视图层（View）: 所呈现出来的页面
  - 业务逻辑层（ViewModel）: 框架封装的核心

  逻辑层的主要职责是：数据变化后更新视图，视图变化后更新数据

#### 6. 为什么 data 属性是一个函数而不是一个对象

- 根实例对象 data 可以是对象也可以是函数（根实例是单例），不会产生数据污染情况

- 组件实例对象 data 必须为函数，目的是为了防止多个组件实例对象之间共用一个 data，产生数据污染。采用函数的形式，initData 时会将其作为工厂函数都会返回全新 data 对象

通俗的讲就是：

因为对象是一个引用数据类型，如果 data 是一个对象的情况下会造成所有组件共用一个 data。而当 data 是一个函数的情况下，每次函数执行完毕后都会返回一个新的对象，这样的话每个组件都会维护一份独立的对象（data）

#### 7. 动态路由是什么

- ##### 动态路由的理解

  - 动态路由就是把匹配某种模式下的路由映射到同个组件中，其实本质就是通过 url 进行传参

  - 比如说：有一个商品 Goods 的组件，我们需要让不同的商品 id 都映射到这个组件中，此时就需要用到动态路由了。

- ##### 动态路由的配置

  可以通过两种方式来传递动态参数

  - 1）params

    - 配置路由的方式： 使用冒号：绑定动态参数

      ```js
      const routes = [
        {
          path: "/goods/:id",
          component: Goods,
        },
      ];
      ```

    - 路由跳转方式

      - （1）使用 router-link 方式实现路由跳转

        ```js
          //方式一
          <router-link :to="'/goods/' + id">商品</router-link>
          //方式二
          <router-link :to="{name: 'goods', params: {id: goodsId}}">商品</router-link>
        ```

        **_注意：_**

        - params 方法中，to 属性使用对象的方式，必须由 name 属性引入路由，不能用 path。
        - params 方法传参时，属性名必须跟配置路由时的动态参数名一致，否则报错。

      - (2) 使用$router 的方式进行路由的跳转

        ```js
        //方法一
        this.$router.push("/goods/" + this.goodsId);

        //方法2
        this.$router.push({
          name: "goods",
          params: {
            id: this.goodsId,
          },
        });
        ```

    - 获取参数方式

      $route.params

  - 2）query

    - 配置路由时，普通配置即可，即原来怎么配置路由，现在就还怎么配置。如：
      ```js
      const routes = [
        {
          path: "/goods",
          name: "goods",
          component: Goods,
        },
      ];
      ```
    - 路由跳转方式

      - （1）使用 router-link 方式实现路由跳转

        query 传参的方式这可以通过对象，不可以使用字符串

        ```js
          <router-link :to="{path: '/goods', query: {id: goodsId}}">商品</router-link>
        ```

      - （2）使用$router 的方式进行路由的跳转

        ```js
        this.$router.push({
          path: "/goods",
          query: {
            id: this.goodsId,
          },
        });

        this.$router.push({
          path: "/goods",
          query: {
            id: this.goodsId,
          },
        });
        ```

      **_注意：_**

      - query 方式的传参，query 对象里面的属性名（如本例中的 id）可以随便起名，不像 params 方式传参时受限。
      - 同时，此种方式下路由的引入既可以使用 path 属性，也可以使用 name 属性。

    - 获取参数方式

      $route.query

#### 8. 自定义 vue 指令，怎么实现，有哪些应用场景

- ##### 如何实现

  注册一个自定义指令有全局注册与局部注册

  全局注册注册主要是用过 Vue.directive 方法进行注册

  Vue.directive 第一个参数是指令的名字（不需要写上 v-前缀），第二个参数可以是对象数据，也可以是一个指令函数

  ```js
  // 注册一个全局自定义指令 `v-focus`
  Vue.directive("focus", {
    // 当被绑定的元素插入到 DOM 中时……
    inserted: function (el) {
      // 聚焦元素
      el.focus(); // 页面加载完成之后自动让输入框获取到焦点的小功能
    },
  });
  ```

  局部注册通过在组件 options 选项中设置 directive 属性

  ```js
    directives: {
      focus: {
        // 指令的定义
        inserted: function (el) {
          el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
        }
      }
    }
  ```

  然后你可以在模板中任何元素上使用新的 v-focus property，如下：

  ```js
  <input v-focus />
  ```

- ##### 应用场景

  使用自定义组件组件可以满足我们日常一些场景，这里给出几个自定义组件的案例：

  - 防抖
  - 图片懒加载
  - 一键 Copy 的功能

  - 输入框防抖

    防抖这种情况设置一个 v-throttle 自定义指令来实现

    举个例子：

    ```js
      // 1.设置v-throttle自定义指令
      Vue.directive('throttle', {
        bind: (el, binding) => {
          let throttleTime = binding.value; // 防抖时间
          if (!throttleTime) { // 用户若不设置防抖时间，则默认2s
            throttleTime = 2000;
          }
          let cbFun;
          el.addEventListener('click', event => {
            if (!cbFun) { // 第一次执行
              cbFun = setTimeout(() => {
                cbFun = null;
              }, throttleTime);
            } else {
              event && event.stopImmediatePropagation();
            }
          }, true);
        },
      });
      // 2.为button标签设置v-throttle自定义指令
      <button @click="sayHello" v-throttle>提交</button>
    ```

  - 图片懒加载

    设置一个 v-lazy 自定义组件完成图片懒加载

    ```js
    const LazyLoad = {
      // install方法
      install(Vue, options) {
        // 代替图片的loading图
        let defaultSrc = options.default;
        Vue.directive("lazy", {
          bind(el, binding) {
            LazyLoad.init(el, binding.value, defaultSrc);
          },
          inserted(el) {
            // 兼容处理
            if ("IntersectionObserver" in window) {
              LazyLoad.observe(el);
            } else {
              LazyLoad.listenerScroll(el);
            }
          },
        });
      },
      // 初始化
      init(el, val, def) {
        // data-src 储存真实src
        el.setAttribute("data-src", val);
        // 设置src为loading图
        el.setAttribute("src", def);
      },
      // 利用IntersectionObserver监听el
      observe(el) {
        let io = new IntersectionObserver((entries) => {
          let realSrc = el.dataset.src;
          if (entries[0].isIntersecting) {
            if (realSrc) {
              el.src = realSrc;
              el.removeAttribute("data-src");
            }
          }
        });
        io.observe(el);
      },
      // 监听scroll事件
      listenerScroll(el) {
        let handler = LazyLoad.throttle(LazyLoad.load, 300);
        LazyLoad.load(el);
        window.addEventListener("scroll", () => {
          handler(el);
        });
      },
      // 加载真实图片
      load(el) {
        let windowHeight = document.documentElement.clientHeight;
        let elTop = el.getBoundingClientRect().top;
        let elBtm = el.getBoundingClientRect().bottom;
        let realSrc = el.dataset.src;
        if (elTop - windowHeight < 0 && elBtm > 0) {
          if (realSrc) {
            el.src = realSrc;
            el.removeAttribute("data-src");
          }
        }
      },
      // 节流
      throttle(fn, delay) {
        let timer;
        let prevTime;
        return function (...args) {
          let currTime = Date.now();
          let context = this;
          if (!prevTime) prevTime = currTime;
          clearTimeout(timer);

          if (currTime - prevTime > delay) {
            prevTime = currTime;
            fn.apply(context, args);
            clearTimeout(timer);
            return;
          }

          timer = setTimeout(function () {
            prevTime = Date.now();
            timer = null;
            fn.apply(context, args);
          }, delay);
        };
      },
    };
    export default LazyLoad;
    ```

#### 9. keeplive 是什么，实现原理

- ##### Keep-alive 是什么

  keep-alive 是 vue 中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染 DOM

  keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们

  keep-alive 可以设置以下 props 属性：

  - include - 字符串或正则表达式。只有名称匹配的组件会被缓存
  - exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存
  - max - 数字。最多可以缓存多少组件实例

  关于 keep-alive 的基本用法：

  - 在动态组件中的应用：

    ```js
    <keep-alive :include="whiteList" :exclude="blackList" :max="amount">
      <component :is="currentComponent"></component>
    </keep-alive>
    ```

  - 在 vue-router 中的应用

    ```js
    <keep-alive :include="whiteList" :exclude="blackList" :max="amount">
        <router-view></router-view>
    </keep-alive>
    ```

  设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated 与 deactivated）：

  - 首次进入组件时：beforeRouteEnter > beforeCreate > created> mounted > activated > ... ... > beforeRouteLeave > deactivated

  - 再次进入组件时：beforeRouteEnter >activated > ... ... > beforeRouteLeave > deactivated

- ##### 使用场景

  使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用 keepalive

  举个栗子:

  当我们从首页–>列表页–>商详页–>再返回，这时候列表页应该是需要 keep-alive

  从首页–>列表页–>商详页–>返回到列表页(需要缓存)–>返回到首页(需要缓存)–>再次进入列表页(不需要缓存)，这时候可以按需来控制页面的 keep-alive

  在路由中设置 keepAlive 属性判断是否需要缓存

  ```js
    {
      path: 'list',
      name: 'itemList', // 列表页
      component (resolve) {
        require(['@/pages/item/list'], resolve)
      },
      meta: {
        keepAlive: true,
        title: '列表页'
      }
    }
  ```

  使用<keep-alive>

  ```js
    <div id="app" class='wrapper'>
      <keep-alive>
        <!-- 需要缓存的视图组件 -->
        <router-view v-if="$route.meta.keepAlive"></router-view>
      </keep-alive>
      <!-- 不需要缓存的视图组件 -->
      <router-view v-if="!$route.meta.keepAlive"></router-view>
    </div>
  ```

#### 10. 虚拟 DOM diff

- ##### 什么是虚拟 DOM

  虚拟 DOM 本质上是一个 js 对象 ，通过对象来表示真实的 DOM 结构。

  虚拟 DOM 的本质就是  JavaScript 对象，使用 JavaScript 对象来描述 DOM 的结构。

  应用的各种状态变化首先作用于虚拟 DOM，最终映射到 DOM。

- ##### 为什么要使用虚拟 DOM

  - 1）.  使用虚拟 DOM，可以避免用户直接操作 DOM，开发过程关注在业务代码的实现，不需要关注如何操作 DOM 以及 DOM 的浏览器兼容问题，从而提高开发效率

  - 2）.  作为一个中间层可以跨平台，除了 Web 平台外，还支持 SSR（服务端渲染）、Weex（跨移动端平台）

- ##### 是什么 diff 算法

  diff 算法就是进行虚拟节点对比，并返回一个 patch 对象，用来存储两个节点不同的地方，最后用 patch 记录的消息去局部更新 Dom。

  diff 的过程就是调用名为 patch 的函数，比较新旧节点，一边比较一边给真实的 DOM 打补丁

  特点：

  - 比较只会在同层级进行, 不会跨层级比较

  - 在 diff 比较的过程中，循环从两边向中间比较

#### 11. vue 中 key 的作用

- ##### Key 是什么

  key 是给每一个 vnode 的唯一 id，也是 diff 的一种优化策略，可以根据 key，更准确，更快的找到对应的 vnode 节点

  Key 是对节点进行的一个标识，在 Vue 中，Key 作为 Vue 中对比算法的标识，在数据修改后，可以通过 Key 进行这个唯一标识进行对比虚拟 DOM，从而决定对节点的重新加载以及复用

- ##### Key 的作用

  设置 key 能够大大减少对页面的 DOM 操作，提高了 diff 效率

  Key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】, 随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异比较。

- ##### Key 的对比规则

  - 旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：

    - 若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM！
    - 若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM。

  - 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key

    - 创建新的真实 DOM，随后渲染到到页面。实例展示

#### 12. Vue 组件间通信方式都有哪些

- ##### 组件间通信的分类

  组件间通信的分类可以分成一下

  - 父子组件之间的通信
  - 兄弟组件之间的通信
  - 祖孙与后代组件之间的通信
  - 非关系组件间之间的通信

- ##### 组件间通信的方案

  整理 vue 中 8 种常规的通信方案

  - 1）通过 props 传递
  - 2）通过 $emit 触发自定义事件
  - 3）使用 ref
  - 4）EventBus
  - 5）$parent 或 $root
  - 6）attrs 与 listeners
  - 7）Provide 与 Inject
  - 8）Vuex

  ##### 1) props 传递数据

  - 适用场景：父组件传递数据给子组件
  - 子组件设置`props`属性，定义接收父组件传递过来的参数
  - 父组件在使用子组件标签中通过字面量来传递值

  ```js
    // Children.vue
    props:{
      // 字符串形式
      name:String // 接收的类型参数
      // 对象形式
      age:{
        type:Number, // 接收的类型为数值
        defaule:18,  // 默认值为18
        require:true // age属性必须传递
      }
    }

    // Father.vue
    <Children name="jack" age=18 />
  ```

  ##### 2) $emit 触发自定义事件

  - 适用场景：子组件传递数据给父组件
  - 子组件通过`$emit`触发自定义事件，`$emit`第二个参数为传递的数值
  - 父组件绑定监听器获取到子组件传递过来的参数

  ```js
    //Children.vue
    this.$emit('add',good)

    //Father.vue
    <Children @add"cartAdd($event)"></Children>

  ```

  ##### 3）ref

  - 父组件在使用子组件的时候设置`ref`
  - 父组件通过设置子组件`ref`来获取数据

  ```js
  //父组件
  <Children ref="foo" />;

  this.$refs.foo; // 获取子组件实例，通过子组件实例我们就能拿到对应的数据
  ```

  ##### 4) EventBus

  - 使用场景：兄弟组件传值
  - 创建一个中央时间总线`EventBus`
  - 兄弟组件通过`$emit`触发自定义事件，`$emit`第二个参数为传递的数值
  - 另一个兄弟组件通过`$on`监听自定义事件

  bus.js

  ```js
  // 创建一个中央时间总线类
  class Bus {
    constructor() {
      this.callbacks = {}; // 存放事件的名字
    }
    $on(name, fn) {
      this.callbacks[name] = this.callbacks[name] || [];
      this.callbacks[name].push(fn);
    }
    $emit(name, args) {
      if (this.callbacks[name]) {
        this.callbacks[name].forEach((cb) => cb(args));
      }
    }
  }

  // main.js
  Vue.prototype.$bus = new Bus(); // 将$bus挂载到vue实例的原型上
  // 另一种方式
  Vue.prototype.$bus = new Vue(); // Vue已经实现了Bus的功能
  ```

  children1.vue

  ```js
  this.$bus.$emit("foo");
  ```

  children2.vue

  ```js
  this.$bus.$on("foo", this.handle);
  ```

  ##### 5) $parent 或$ root

  - 通过共同祖辈`$parent`或者`$root`搭建通信桥梁

  ```js
  //兄弟组件
  this.$parent.on("add", this.add);

  //另一个兄弟组件
  this.$parent.emit("add");
  ```

  ##### 6）$attrs 与 $listeners

  - 适用场景：祖先传递数据给子孙
  - 设置批量向下传属性`$attrs`和`$listeners`
  - 包含了父级作用域中不作为`prop`被识别（且获取）的特性绑定（class 和 style 除外）
  - 可以通过 `v-bind="$attrs"` 传入内部组件

  ```js

    // child：并未在props中声明foo
    <p>{{$attrs.foo}}</p>

    // parent
    <HelloWorld foo="foo"/>

    // 给Grandson隔代传值，communication/index.vue
    <Child2 msg="lalala" @some-event="onSomeEvent"></Child2>

    // Child2做展开
    <Grandson v-bind="$attrs" v-on="$listeners"></Grandson>

    // Grandson使⽤
    <div @click="$emit('some-event', 'msg from grandson')">
      {{msg}}
    </div>

  ```

  ##### 7) provide 与 inject

  - 在祖先组件定义`provide`属性，返回传递的值
  - 在后代组件通过`inject`接收组件传递过来的值

  ```js
    //祖先组件

    provide(){
      return {
        foo: 'foo'
      }
    }

    //后代组件

    inject: ['foo'] //获取到祖先组件传递过来的值

  ```

  ##### 8）vuex

  - 适用场景：复杂关系的组件数据传递
  - `vuex`作用相当于一个用来存储共享变量的容器
  - `state` 用来存放共享变量的地方，（相当于`store`中的`data`）
  - `getter`，可以增加一个`getter`派生状态，（相当于`store`中的计算属性），用来获取共享变量的值
  - `mutation` 用来存放修改`state`的方法
  - `action` 也是用来存放修改`state`的方法，不过`action`是在`mutation`的基础上进行。常用来做一些异步操作

#### 13. 什么是单向数据流

- 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

- 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。

**_单向数据流：父级 prop 的更新会向下流动到子组件中，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值_**

#### 14. 如何让 vue 页面重新渲染

- 方法一

  使用 vue 内置的 forceUpdate 方法

  ```js
  this.$forceUpdate(); //这不会更新您拥有的任何计算属性,调用forceUpdate只会强制重新渲染视图
  ```

- 方法二

  在元素上绑定一个 key,当 key 修改时,该 DOM 元素就会重新渲染

  ```js
    <template>
      <div :key="once"></div>
    </template>

    export default{
      data(){
        return{
          once:0,
        }
      },
      methods:{
        forceRerender(){
          this.once +=1
        }
      }
    }
  ```

#### 15. 说说你对 slot 的理解？slot 使用场景有哪些？

- ##### slot 是什么

  在 HTML 中`slot`元素，作为`Web Components`技术套件的一部分，是 Web 组件内的一个占位符，该占位符可以在后期使用自己的标记语言填充

  在 Vue 中的概念也是如此

  `Slot` 艺名插槽，花名“占坑”，我们可以理解为`solt`在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中`slot`位置），作为承载分发内容的出口

- ##### 使用场景

  通过插槽可以让用户可以拓展组件，去更好的复用组件和对其做定制化处理

  如果父组件在使用到一个复用的组件的时候，获取这个组件在不同的地方少量的更改，如果去重写组件是一键不明智的事情

  通过`slot`插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用

  比如布局组件、表格列、下拉选、弹框显示内容等

- ##### 分类

  `slot`可以分成一下三种

  - 默认插槽
  - 具名插槽
  - 作用域插槽

  - ##### 作用域插槽

    子组件用`<solt>`标签来确定渲染的位置，标签里面可以放 DOM 结构，当父组件使用的时候没有往插槽传入内容，标签内 DOM 结构就会显示在页面

    父组件在使用的时候，直接在子组件的标签内写入内容即可

    子组件 Child.vue

    ```js
    <template>
      <slot>
        <p>插槽后备的内容</p>
      </slot>
    </template>
    ```

    父组件

    ```js
    <Child>
      <div>默认插槽</div>
    </Child>
    ```

  - ##### 具名插槽

  子组件用`name`属性来表示插槽的名字，不传为默认插槽

  父组件中在使用时在默认插槽的基础上加上`slot`属性，值为子组件插槽`name`属性值

  子组件 Child.vue

  ```js
  <template>
    <slot>插槽后备的内容</slot>
    <slot name="content">插槽后背的内容</slot>
  </template>
  ```

  父组件

  ```js
    <Child>
      <templage v-slot:default>具名插槽</templage>
      <!-- 具名插槽用插槽名做参数 -->
      <template v-slot:content>内容...</template>
    </Child>
  ```

  - ##### 作用域插槽

  子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件 v-slot 接受的对象上

  父组件中在使用时通过 v-slot：（简写：#）获取子组件的信息，在内容中使用

  子组件 Child.vue

  ```js
  <template>
    <slot name="footer" testProps="子组件的值">
      <h3>没传footer插槽</h3>
    </slot>
  </template>
  ```

  父组件

  ```js
    <child>
      <!-- 把v-slot的值指定为作用域上下文对象 -->
      <template v-slot:default="slotProps">
        来自子组件数据:{{slotProps.testProps}}
      </template>
      <template #default="slotProps">
        来自子组件数据:{{slotProps.testProps}}
      </template>
    </child>
  ```

#### 16. 观察者模式和订阅发布模式的区别？

观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。

![img](https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

从图中可以看出，观察者模式中观察者和目标直接进行交互，而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。

代码实现

观察者模式：

```js
// 观察者
class Observer {
  constructor() {}
  update(val) {}
}
// 观察者列表
class ObserverList {
  constructor() {
    this.observerList = [];
  }
  add(observer) {
    return this.observerList.push(observer);
  }
  remove(observer) {
    this.observerList = this.observerList.filter((ob) => ob !== observer);
  }
  count() {
    return this.observerList.length;
  }
  get(index) {
    return this.observerList[index];
  }
}
// 目标
class Subject {
  constructor() {
    this.observers = new ObserverList();
  }
  addObserver(observer) {
    this.observers.add(observer);
  }
  removeObserver(observer) {
    this.observers.remove(observer);
  }
  notify(...args) {
    let obCount = this.observers.count();
    for (let index = 0; index < obCount; index++) {
      this.observers.get(i).update(...args);
    }
  }
}
```

发布订阅模式：

```js
class PubSub {
  constructor() {
    this.subscribers = {};
  }
  subscribe(type, fn) {
    if (!Object.prototype.hasOwnProperty.call(this.subscribers, type)) {
      this.subscribers[type] = [];
    }

    this.subscribers[type].push(fn);
  }
  unsubscribe(type, fn) {
    let listeners = this.subscribers[type];
    if (!listeners || !listeners.length) return;
    this.subscribers[type] = listeners.filter((v) => v !== fn);
  }
  publish(type, ...args) {
    let listeners = this.subscribers[type];
    if (!listeners || !listeners.length) return;
    listeners.forEach((fn) => fn(...args));
  }
}

let ob = new PubSub();
ob.subscribe("add", (val) => console.log(val));
ob.publish("add", 1);
```

从上面代码可以看出，观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，会造成代码的冗余。而发布订阅模式则统一由调度中心处理，消除了发布者和订阅者之间的依赖。

观察者模式跟我们平时用的事件也有一定的关系，比如：

```js
ele.addEventListener('click', () => {});
```

addEventListener就相当于注册了一个观察者，当观察到‘click’事件的时候，作出一些处理。

#### 17. $nextTick 的作用和原理？

- ##### NextTick是什么

  官方对其的定义

    > 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
  
  什么意思呢？

  我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新

- ##### 使用场景

  如果想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick()

  第一个参数为：回调函数（可以获取最近的DOM结构）

  第二个参数为：执行函数上下文

  组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上

- ##### 实现原理

  - 把回调函数放入callbacks等待执行

  - 将执行函数放到微任务或者宏任务中

  - 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调

#### 18. 说说你对vue的mixin的理解，有什么应用场景？

- ##### mixin是什么

  ##### Vue中的mixin

    先来看一下官方定义

    > mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。

    本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods 、created、computed等等

    我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来

    在Vue中我们可以局部混入跟全局混入

    - 局部混入

      定义一个mixin对象，有组件options的data、methods属性

      ```js
        var myMixin = {
          created: function () {
            this.hello()
          },
          methods: {
            hello: function () {
              console.log('hello from mixin!')
            }
          }
        }
      ```
      组件通过mixins属性调用mixin对象

      ```js
        Vue.component('componentA',{
          mixins: [myMixin]
        })
      ```

      该组件在使用的时候，混合了mixin里面的方法，在自动执行create生命钩子，执行hello方法

    - 全局混入

      通过Vue.mixin()进行全局的混入

      ```js
        Vue.mixin({
          created: function () {
            console.log("全局混入")
          }
        })
      ```

    ***使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）***

    PS：全局混入常用于插件的编写

  ##### 注意事项：

    - 当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项

    - 但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子

- ##### 使用场景
  
  在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立

  这时，可以通过Vue的mixin功能将相同或者相似的代码提出来


#### 19. 用 promise 实现图片的懒加载

- ##### 懒加载的原理

  一张图片就是一个img标签,浏览器是根据src的属性发起图片请求的.那么我们实现的依据就是当前图片出现在可视屏幕上,就把图片的地址赋值(或替换)给img的src属性.

- ##### 懒加载的实现步骤

  - 默认loading图片
  - 判断哪些需要加载(难点)
  - 预缓存在浏览器
  - 替换真图片

- ##### 代码实现

  - 默认loading 图片

    loading 找一些1-2k的图片，越小越好，放置本地public 目录

    ```js
      <template>
        <div class="img-loading-container" ref="imgBox">
          <img
            v-for="(item,index) in 5"
            :key="index"
            src="@/assets/loading.gif"
            alt=""
          >
        </div>
      </template>
    ```

  - 判断哪些需要加载

    ![img](https://www.freesion.com/images/702/a4bd8ea72a2d905fc00fd370ac251c66.png)

    如上图所示, 当图片(指当前需要加载的图片)距离顶部的距离小于可视区域h和滚动区域高度s之和时说明图片进入可视化区域了,即top-height < s+h时，图片在可视区。

    介绍用到的api函数:

      - 网页被卷去的高： document.body.scrollTop;

      - 可视区域高度: window.innerHeight

      - 当前对象到浏览器顶部的距离: domObject.offsetTop
    
    ```js
      <script>
        export default {
          data () {
            return {
              imgList: [
                {
                  url: 'https://.../distribution-web/upLoad/img/ceshi/1.jpg'
                },
                {
                  url: 'https://.../distribution-web/upLoad/img/ceshi/2.jpg'
                },
                {
                  url: 'https://.../distribution-web/upLoad/img/ceshi/3.jpg'
                },
                {
                  url: 'https://.../distribution-web/upLoad/img/ceshi/4.jp' // 这是故意写错的
                },
                {
                  url: 'https://.../distribution-web/upLoad/img/ceshi/5.jpg'
                }
              ],
              present: {
                old: -1,
                new: 0
              }
            }
          },
          mounted () {
            // 进入当前页面就加载
            setTimeout(this.getImgList, 300)
            // 监听滚动事件
            window.addEventListener('scroll', this.getImgList)
          },
          methods: {
            getImageCache (imgNodes, id) {
              return new Promise((resolve, reject) => {
                // 创建一个image对象
                var temp = new Image();
                // 预先把加载的图片加入内存中(隐形加载),相当于给浏览器缓存了一张图片
                temp.src = this.imgList[id].url
                // 成功的状态
                temp.onload = () => {
                  imgNodes[id].src = temp.src
                  resolve('第' + (id + 1) + '张图片加载成功')        };
                // 失败的状态
                temp.onerror = () => reject('第' + (id + 1) + '张图片加载失败了');
              })
            },
            getImgList () {
              // 获取所有img的DOM对象
              const imgNodes = this.$refs.imgBox.childNodes
              // 可视区域高度
              const h = window.innerHeight;
              // 滚动区域高度
              const s = document.documentElement.scrollTop || document.body.scrollTop;

              for (let i = this.present.new; i < imgNodes.length; i++) {
                // 可视区域和滚动区域之和时懒加载大于图片距离顶部的距离
                if ((h + s) > imgNodes[i].offsetTop) {
                  // 已加载的最大下标赋值给present做记录,防止再循环
                  this.present.new = i
                  // 当加载的最大下标值和上一次的下标值相等时,防止再请求
                  if (this.present.old !== this.present.new) {
                    this.getImageCache(imgNodes, i).then((success) => {
                      console.log(success)
                    }).catch((error) => {
                      console.log(error)
                      imgNodes[i].src = require('@/assets/error.jpg')
                    })
                    // 把当前最大下标值赋值给上一次最大下标值
                    this.present.old = this.present.new
                  }
                }
              }
            }
          }
        }
      </script>
    ```

  可能会遇到的问题

  - 1.当图片的height的数值设置为auto时,你会发现domObject.offsetTop(当前对象到浏览器顶部的距离)的值很小,然后你用domObject.offsetHeight(获取dom对象的高度)发现值为0!,解决方法有加个一次性计时器,还有就是放置在temp.onload中

  - 2. 当你运用我的代码,打开浏览器的调试network时,每一张图片居然会加载两次或者很多次! 你再仔细看看你加载图片的Request Headers的两个属性,分别是cache-control和pragma。 他们的值都为no-cache(禁止缓存)，这就是你浏览器的设置问题了，你在Disable cache打了勾，去掉就行了

#### 20. Vue按需加载怎么实现
- ##### Vue按需加载的几种方法

  为什么要使用路由的按需加载

  对于Vue这种单页面的应用，如果没有应用懒加载的，在运行webpack打包后的文件会过大，会造成进入首页时需要加载的内容过多，加载造成的白屏时间过长，即使在项目中做了loading也会不利于用户的体验。而运用了按需加载可以对界面进行划分，需要的时候加载界面可以有效的分担首页说承担 的加载压力，减少首页加载用时，也可以减轻服务器的负载。

  实现方法

  **Vue按需加载组件-使用webpack require.ensure**

    使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。如示例中chunkName为demo1的将会打包成一个js文件，chunkName为demo2的将会打包成一个js文件。

    ```js
      // r就是resolve
      {
        path: '/home',
        name: 'home',
        component: r => require.ensure([], () => r(require('@/components/home')), 'demo1')
      }, {
        path: '/index',
        name: 'Index',
        component: r => require.ensure([], () => r(require('@/components/index')), 'demo1')
      }, {
        path: '/about',
        name: 'about',
        component: r => require.ensure([], () => r(require('@/components/about')), 'demo2')
      }

      require.ensure(dependencies: String[], callback: function(require), chunkName: String)
    ```

    - 依赖 dependencies

      这是一个字符串数组，通过这个参数，在所有的回调函数的代码被执行前，我们可以将所有需要用到的模块进行声明。

    - callback
    
      当所有的依赖都加载完成后，webpack会执行这个回调函数。require 对象的一个实现会作为一个参数传递给这个回调函数。因此，我们可以进一步 require() 依赖和其它模块提供下一步的执行。

    - chunkName

      chunkName 是提供给这个特定的 require.ensure() 的 chunk 的名称。通过提供 require.ensure() 不同执行点相同的名称，可以将相同名称的依赖打包在同一个JS文件中

      ***需要注意的是，在使用 require.ensure后该模块只会下载下来，并不会执行，只有当回调函数执行后该模块才会执行***

  **vue异步组件**

    使用vue的异步组件 , 实现按需加载，每个组件生成一个js文件，实现组件的懒加载。(路由懒加载)
    
    ```js
      {
        path: '/problem',
        name: 'problem',
        component: resolve => require(['../pages/home/problemList'], resolve)
      }
    ```

  **使用ES6的import()**

    官方文档推荐的直接将组件引入的方式，impor是ES6的一个语法标准，使用该方法可直接声明导入，在下面路由配置中直接去使用*（需注意该方法需要webpack版本2.4+）

    ```js
      import Vue from 'vue';
      import Router from 'vue-router';
      // 官网可知：下面没有指定webpackChunkName，每个组件打包成一个js文件。
      const Foo = () => import('../components/Foo')
      const Aoo = () => import('../components/Aoo')
      // 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。
      // const Foo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/Foo')
      // const Aoo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/Aoo')
      export default new Router({
        routes: [
          {
            path: '/Foo',
            name: 'Foo',
            component: Foo
          },
          {
            path: '/Aoo',
            name: 'Aoo',
            component: Aoo
          }
        ]
      })
    ```

#### 21. 数据请求在 created 和 mouted 的区别

- created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成

- mounted是在页面dom节点渲染完毕之后就立刻执行的触发时机上created是比mounted要更早的

- 两者相同点：都能拿到实例对象的属性和方法

- 讨论这个问题本质就是触发的时机，放在mounted请求有可能导致页面闪动（页面dom结构已经生成），但如果在页面加载前完成则不会出现此情况

- 建议：放在create生命周期当中

#### 22. vue2 和 vue3 的区别

  - ssr 优化 vue2 Object.defineProperty vue3 Proxy (数据劫持（响应式系统）优化)

  - 语法优化 vue2 Options API vue3 composition API

  - vue3 去掉了中央事件 eventBus， 因为原先实例上的三个方法$on,$off,$once被删除掉了， 添加了 provide, inject

  - vue3 去掉了 filter 过滤器。 与此同时，官方建议：用方法调用或计算属性特换过滤器。

  - diff 算法优化 vue3 在 diff 算法中相比 vue2 增加了静态标记，其作用是为了会发生变化的地方添加一个 flag 标记

  - 静态提升 vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用


