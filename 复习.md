# 前端复习

- ## JS基础

  - ### 基础语法/API

    - #### 数据类型

      - ##### 基本类型

        - Boolean

        - Number(包括NaN)

        - String

        - null/undefiend

        - Symbol生成唯一不可变的值:比如对象唯一属性名(ES2015)

          ```js
          const s = Symbol('name')
          const obj = {
              name:'heihei'
          }
          
          obj[s] = 'abc'//属性不重名
          log(typeof s,obj[s])//"symbol",abc
          
          Object.keys(obj).forEach(item=>{})//此方法获取的属性名数组无法得到symbol属性名
          Object.getOwnPropertySymbols(obj).forEach(item=>{
              log(item,obj[item])
          })
          ```

        - BigInt定义超过Number.MAX_VALUE的特大数值(ES2020),比如银行项目会超过此时增加不变(打印显示绿色)

          - BigInt(string | number | boolean)
          - count + 3n 在数值后边加n转换为bigInt类型
          - bigint类型不可与其他类型运算,只能与bigInt进行算术运算

          ```js
          let count = BigInt(3)
          log(count + 3n)//6n
          log(typeof count)//bigint
          ```

      - ##### 引用类型

        - Object
        - Array
        - Function
        - 其他内置:Date
        - 自定义类型:class

      - ##### 数据类型判断

        ##### undefined和null

        - === :用于判断undefined和null

        ##### 基本数据

        - typeof()  : 返回类型小写,null对象数组等所有非函数对象都返回object
        - A instanceof Array :返回true/false判断A原型链上对象是否为B类型的实例 ,比如typeof无法区分数组和对象
        - []/{}.constructor :得到对象类型的构造函数和Number/Boolean/String的包装类型的构造函数(null/undefined没有包装类型)

        ##### 引用类型

        - Array.isArray([]) : 专门用来判断数组

        - String.prototype.toString.call({})

          为了让任意对象都能调用Object原型上的toString方法,需要利用call进行toString重写,返回"[object 类型名称]"字符串然后slice截取

          ```js
          const arr = [1,2]
          const type = Object.prototype.toString.call(arr).slice(8,-1)//Array
          
          if(typeof(arr)==='object'){
              //引用类型
              if(Array.isArray(arr)){
                  //数组
              }else if(arr===null){
                  
              }else if(arr===undefined){
                  
              }else{
                  //对象
              }
          }else if(typeof(arr)==="function"){
              //函数
          }else{
              //基本类型
          }
          ```

        

      

    - #### 数组常用方法

      - 遍历元素(forEach)

        查找:find/findIndex

        条件:every/some

        返回新数组:map/filter/reduce

      - 7个更新数组

        尾头操作:push/pop/unshift/shift

        任意位置:splice(索引,元素)

        正倒排序:sort(function(a,b){return a.age - b.age}) / reverse

      - 其他

        切拼:slice/concat/join

        查包:indexOf(val)没有索引返回-1 / includes

    

    

    - #### 作用域

      - ##### 分类

        - 全局  / 函数 / 块(if/for/while) / 词法/静态作用域:是JS在编写时就确定的规则
        - 对象本身不产生作用域
        - const/let/class不会添加为window的属性

      - ##### 作用域链(全局/函数变量对象组成的数组)

        - 用于多个嵌套结构由内向外查找变量
        - 浏览器引擎解析时确定
        - 本质是一个数组里边放由内向外调用函数产生的变量对象,对象用于存储局部变量

      - ##### 变量提升

        - 执行全局代码和函数时会进行"预解析",将var和function声明放到最前边,(let/const/class)以及函数表达式没有提升
        - 表达式: 会返回一个可使用的数据值,没有分号不能独立存在: 3/""/true/{}/[]/变量/匿名函数/函数调用  和 变量与值运算/判断

      - ##### this指向(运行时动态绑定的)

        - 默认绑定:直接调用fn()  默认为window/严格模式下undefined,严格模式下声明变量不能省略var,且this指向window

        - 隐式绑定:obj.fn()

        - 显式绑定:fn.call/apply/bind(this指向的对象)

        - 构造函数绑定:通过new fn()的构造出来的实例对象

        - 特殊情况

          - 箭头函数没有自己的this,this是一个内置的变量所以会通过作用域链指向外部作用域
          - 回调函数
            - 定时器/ajax/promise/数组带遍历的方法 =>window/undefined
            - vue控制的回调函数=>该组件实例对象
            - react控制的周期回调=>组件实例对象  / 事件监听回调=>undefined

        - ##### 改变this指向

          - ES6之后用箭头函数,之前在外部that=this然后通过作用域链用that
          - fn.call()/apply(this对象):改变函数的this指向并立即调用fn,fn.bind()只修改this指向并返回fn函数

      

    - #### 闭包

      本质是一个对象被内部函数引用着,通过chrome debugger调试工具查看

      - ##### 产生:

        - 外部函数声明嵌套内部函数且引用了外部函数的变量,调用外部函数创建了内部函数

          ##### 使用

          外部函数return内部函数,然后调用内部函数

          ##### 释放

        - 将指向外部函数的变量赋值为null释放闭包

      - ##### 作用

        - 延长局部变量的生命周期避免调用后内存释放,外部函数断开引用被垃圾回收
        - 提供功能外部使用但不想让其看到我内部实现的逻辑
        - 外部可以反复操作局部变量(内部函数return 变量)

      - ##### 应用

        - 匿名函数自调用

        - 函数柯里化

        - 模块化编译时

          会给模块代码包裹一层匿名函数自调用,并return一个对象暴露出去

      

    - #### 原型

      定义新函数同时JS引擎会在内存总创建构造函数对象0*123,它默认的显示原型对象会指向new Object()的实例对象相当于一个{}  0 *234

      {}原型对象上有个constructor属性会指回构造函数对象0 * 123

      当函数new实例化对后会创建一个实例对象0*345,它的隐式原型属性:_proto__就是构造函数的显示原型属性:prototype 0 * 234,同时指向Object的实例对象

      ```js
      function Fn(){}
      //伪代码
          const Fn = new Function() // 0 * 123
          Fn.prototype = {} // 0 * 234
      	Fn.prototype.constructor = fn // 0 * 123
      
      new Fn()
      //伪代码
      	const fnObj = new Fn() //0 * 345
          fnObj.__proto__ = Fn.prototype //0 * 234
      ```

      

      - ##### 原型链

        ![原型链](C:\Users\ahanv\Desktop\java\原型链.png)

        - 通过对象的__ proto __隐式原型属性连接所有对象,从而在查找对象属性时:先在自身找,找不到通过隐式原型链往上找直到undefined
        - 所有构造函数都是Function的实例对象包括自己:Function.prototype===Function._proto 和 Fn.__proto === Function.prototype
        - 构造函数的prototype显式原型属性,只在构建实例对象时赋值给实例对象的__ proto _隐式原型属性,并利用constructor属性指回构造函数
          - 所有对象都是Object的实例所以所有实例对象的proto都指向Object.prototype,隐式原型链的尽头:Object.prototype=Object.prototype.proto_=null

        ##### JS引擎解析代码前:

        - JS引擎在解析代码前先执行内置代码定义出内置的构造函数或类型对象:Function/Object/Array/String/Reg/Date/Math等
        - Function.prototype时一个函数不为对象非Object所构造,所以JS引擎内置强绑使其加入隐式原型链,从而:Function instanceof Object为true

        ```js
        //JS引擎内部两段伪代码
        Function.prototype.__proto__ = Object.prototype
        Object.prototype.__proto__=null
        ```

        

      - ##### instanceof原理

        给对象从隐式原型链上比对某个原型对象Type.prototype

        ```js
        function myInstanceOf(obj,Type){
            let objProto = obj.__proto__
            while(objProto){
                //只要还有圆形对象就继续判断查找
                if(objProto === Type.protoType)return true
                //取出下一个隐式原型
                objProto = objProto.__proto__
            }
            return false
        }
        
        log(myInstanceOf({},Object))
        ```

        

      - ##### 继承

        - ##### 构造函数(原型链)

          ```js
          //给父类prototype显式原型上添加属性或方法
          function Person(name,age){
              this.name = name
              this.age = age
          }
          Person.prototype.sayInfo = function(){
              console.log(`我叫${this.name},今年${this.age}`)
          }
          const p1 = new Person('韩',26)
          const p2 = new Person('伟',25)
          p1.sayInfo()
          
          
          function Student(name,age,price){
          	//3借用父类型初始化,修改this并传值执行
              Person.call(this,name,age)
              //this.name = name 
              //this.age = age
              this.price = price
          }
          //1让子类原型指回父类型的实例
          Student.prototype = new Person()
          //2让子类原型对象的constructor指回子类型
          Student.prototype.constructor = Student
          //如果父类方法无法满足需求,可重写
          Student.prototype.sayInfo = function(){
              console.log(`我叫${this.name},今年${this.age},月收入${this.price}`)
          }
          
          const s = new Student('Ahanve',22,15000)
          s.sayInfo()
          ```

          

        - ##### ES6的Class类(extends/super)

          ```js
          class Peroson{
              constructor(name,age){
                  this.name = name
                  this.age = age
              }
              sayInfo(){
                  console.log(`${this.name,this.age}`)
              }
          }
          
          class Teacher extends Person{
              //借助父类型的构造器初始化属性
              super(name,age)
              this.course = course
              //无法满足需求,重写父类型方法
              sayInfo(){
                console.log(`${this.name,this.age,this.course}`)
              }
          }
          const t = new Teacher("han",26,'前端')
          t.sayInfo()
          ```

          

      

      - ##### 面向对象三个特性

        - ##### 封装

          变量=>函数=>对象=>模块=>组件=>库...将可复用的代码用一结构包装以反复使用

        - ##### 继承

          JS中的继承本质是基于隐式原型链的继承,便于类型复用减少编码

        - ##### 多态(类型继承+重写方法)

          声明指定一大类型,实际使用可传入任意子类型对象且在子类型中可重写父方法

          - JS是弱类型语言,在声明变量时不用指定类型..但使用函数时可以传入任意类型数据得到不同结果算是多态体现了

          - TS和JAVA强类型语言比较明显

            ```ts
            function test(p:Person){
                p.sayInfo()
            }
            test(new Person())
            test(new Teacher())
            ```

            



- ### 异步

  - #### 区分同异步回调

    - ##### 同步

      - 大部分webApi
      - 数组遍历=>新数组后操作
      - 执行器函数=>触发异步任务

    - ##### 异步回调(先触发将回调放到任务队列中)

      - 定时器

      - promise.resolve("666").then(异步回调)

        

  - #### JS页面渲染顺序

    ![任务队列](C:\Users\ahanv\Desktop\java\任务队列.png)

    ##### 顺序

    - JS引擎线程(解析代码)与GUI线程(绘制页面)和WebApi模块线程(主动触发宏任务),两个不同线程不会同时执行

    - Script第一次宏任务=>所有微任务(最后alert断点下)=>渲染界面=>第二次宏任务(定时器alert断点,但内存中的DOM数据已更新)

    

  - #### JS线程事件循环机制(eventloop)

    ES6之前只有宏任务,塞一个渲染次页面...设计微任务异步是为了减少渲染页面次数从而避免重绘重排,性能高于宏任务尽量使用微任务

    ![JS事件轮回机制](C:\Users\ahanv\Desktop\java\JS事件轮回机制.png)

    - ##### 单线程异步(H5后的webworker启动分线程但不可操作DOM)

      script宏任务(宏任务触发后放入宏队列中)=>所有微任务=>第二个宏任务=>所有微任务

      - ##### JS与webApi线程分工

        - webApi分线程:定时器/AJAX/DOM事件/MutationObserver,用于存放被动触发的宏任务
        - JS引擎线程:宏/微队列

      - ##### 分类 

        - 宏任务: script/定时器/AJAX/DOM事件/postMessage
        - 微任务:promise/MutationObserver(监视DOM元素变化)

      - ##### 特性

        - script是第一个宏任务,但不进入宏队列
        - 全局来看是:先宏后微..但如果一个点击回调内同时有宏微任务则:先微后宏
        - JS引擎解析JS代码时,会将主动触发的回调对应放到宏队列和微队列中..所有被动回调会暂存到对应的webApi管理模块,待到点击/定时/请求回来触发后推入对应的宏微队列中.
        - 然后开始依次将微队列中的微任务回调推入调用栈进行压栈执行,对象会存入堆空间中..并在下次宏任务前调用GUI线程渲染页面

        

  

  - #### ES6的Promise

    - ##### 基本

      - new构建Promise时传入执行器函数(resolve,reject)=>{},返回一个pending状态Promise链式调用

      - catch(err=>{}):专门接受失败回调,只有throw和return Promise.reject(1)才会走

        ```js
        //本质
        .then(val=>val,err=>{})//所以如果上个promise传递成功状态,通过.catch().then(res=>{会将成功的val传到此处},err=>{})
        ```

      - finally():任何状态切换都会走

    - ##### 状态

      pending无状态 / resolve成功 / reject失败,promise只能从无状态切换到成功/失败任一状态

      ```js
      new Promise((resolve,reject)=>{
          //执行器函数无操作则为pending不往下走.then返回一个pending状态promise
          //reject(2)//将pending状态变为失败
          resolve(1)//将pending状态变为成功
      }).then(res=>{
          //成功回调
          //状态切为成功
          //1,返回成功的promise
          return Promise.resolve(1)
          //2,返回任何值
          return 1 
          //3,不返回相当于return undefined
          
          //状态切为失败
          //1,返回失败的promise
          return Promise.reject(1)
          //2,抛出任何值
          throw 3
          
          //状态保持pending,不往下走.then()
          //1,返回无状态的promise
          return new Promise(()=>{})
      },err=>{
          //失败回调
      }).then(res=>{},err=>{})
      ```

    - ##### 静态方法

      - resolve()/reject() :用于创建成功/失败的简易方法

      - all([promise1,promise2]):批量处理多个异步请求,都成功时返回成功的promise,只要一个失败就返回失败的promise..res/err=>{拿到所有promise结果值组成的数组}

      - race([promise1,promise2]): 返回由第一个完成的promise状态决定的promise

      - allSettled([promise1,promise2]):当所有Promise完成时,返回成功/失败对象组成的数组

      - 多个请求后用返回的数据发新请求:

        ```js
        function ajax(url){
        	return axios.get(url)
        }
        const p1 = ajax(url1)
        const p2 = ajax(url2)
        Promise.all([p1,p2]).then(res=>{
            //得到返回的成功数据,发送请求
            ajax(`${url4}+res[0]+res[1]`)
        }).then(res=>{
            //得到新请求返回数据
        }).catch(err=>{
            //只要有一个失败走这 
        })
        ```

        

  - #### async和await

    - 异步编程解决方案,简化promise.then.catch..直接用try/catch和变量接收

    - async方法前缀/await变量接收

      ```js
      const getPro = async ()=>{
      	try{
             	const res =await axios.get('')
          	return res.data
          }catch(err){
              log(err)
              //默认return undefined
          }
      }
      //链式调用
      async function test(){
          const res = await getPro()//data,如果没有return则为成功undefined
      }
      ```

      





- ## WebApi

  - ### 从输入URL到渲染页面过程

    - 浏览器DNS解析得到服务器对应的IP地址

      - 首先浏览器做DNS缓存=>计算机=>路由器=>网络运营商DNS缓存=>递归查询

    - TCP三次握手链接上服务器

    - 客户端发请求报文,服务器处理并返回响应报文

    - ##### 客户端解析响应数据,并显示页面

      - 响应报文是个长字符串,需要客户端调用解析器解析
      - 首先HTML代码,解析成DOM树
      - CSS代码解析成CSSOM树
      - 解析JS代码时遇到修改元素节点的,重调HTML解析器更新DOM树..遇到要修改样式的,重新调CSS解析器更新CSSOM树,最终形成渲染树
      - 进行layout布局,计算元素的位置和大小
      - 进行render渲染颜色,文字,图片

    - 如果两端长时间无交互,会自动TCP四次挥手断开链接

      

  - ### 回流和重绘

    - ##### 回流(重排)

      更新DOM或style时,会重新进行布局..如果只改颜色就不会重排只重绘

      浏览器窗口尺寸改变/新增或删除DOM元素/元素位置大小改变/读取窗口属性

    - ##### 重绘

      只进行render更新元素部分外观属性,不会影响到layout布局

    - ##### 区同

      - 重排肯定会重绘,重排比重绘更耗性能
      - 减少重排回流次数:尽量通过类名而非style更新
      - 将DOM操作离线处理,比如DocumentFragment文档碎片(VUE源码用的是:模版语法树=>AST抽象语法树=>调用渲染函数=>diff算法生成虚拟DOM=>真实DOM)

  

  - ### 数据存储

    - #### 浏览器本地缓存

      - ##### 分类

      - ##### Cookie

        - 会话cookie(sessionStorage) / maxAge持久化cookie(localStorage)

      - ##### LocalStorage(H5)/SessionStorage(H5) 区别cookie

        - 刷新时都在,但后者关闭浏览器后数据丢失
        - cookie容量几kb,本地几M
        - 请求时自动携带,但本地需要请求拦截器中读取携带
        - 原生API很少(document.cookie得到一个按;空格隔开的大长串)
        - 浏览器可以禁用,如果一个功能基于cookie开发就废了

      - ##### cookie和session

        - cookie保存在浏览器/客户端,而session保存在服务器端
        - 客户端提交账号密码去服务器端,会对应生成一个session对象
        - 然后服务端将sessionID以cookie形式,还可以setMaxAge(1000*60)持久化返给客户端,每次请求自动携带

  

  - #### 浏览器的强缓存和协商缓存

    - ##### 强缓存:

      每次请求新文件时,服务端都会返回该文件内容通过响应头:hash加密生成的32位字符串Etag和lastModefied修改时间

      之后浏览器会做定时的强缓存,没有过期就直接前台读取(优先从内存读其次从硬盘读)

      F12可看到请求文件Size大小栏里:memory cache内存缓存和size cache磁盘缓存..ctrl+f5强刷清除缓存或者调试时禁用缓存

    - ##### 协商缓存:

      过期后浏览器会在请求头中添加上次请求该文件服务端返回的IF-NONE-MATCH:Etag和IF-MODEFIED-SINCE:Last-Modified

      服务器读取该文件判断是否变化,若没变只用返回304Not-Modified告知浏览器从前台缓存里读,若有变化那么重新加载返回200新文件

    - ##### 服务器判断文件改变

      - 通过md5对文件内容进行hash加密处理生成一个32位字符串和资源最后更新时间,通过响应头Etag和Last-Modefied返回
      - 之前后台是先根据Last-Modefied最后更新时间判断,之后才加入的Etag
      - HTTP1.0规范是Expires响应头设置缓存过期时间
      - HTTP1.1规范是Cache-Control设置max-age设置正确返回时间或者no-cache不准浏览器缓存

  

  

  - ### HTTPS

    - #### HTTP

      数据是明文传输,容易被截取报文..不合适传输敏感信息

    - #### HTTPS

      在http外包装TLS层,加密传输比http完全

    - #### 跨域

      - ##### 浏览器的同源策略

        - 同源:协议,域名,端口都相同(路径可不同)
        - 解析image/link/script标签时不受同源策略限制,但AJAX请求时有跨域限制

      - ##### 三种解决方案

        - CORS

          服务端设置允许跨域的响应头:res.setHeader('"Access-Control-Allow-Origin",'*')

        - JSONP

          利用script不受跨域限制,动态创建一个script标签,并设置type和src地址并通过查询字符串拼上回调名,然后添加到页面并调用,并给服务端响应函数把data传参调用的代码,客户端准备好这个回调调用

          只能处理get请求

        - 反向代理服务器

          开发环境:就是webpack-dev-server中的http-proxy-middleware插件进行正向代理

          生产环境:利用ngix服务器进行反向代理

          

    - #### RestlessAPI和RestfulAPI

      - ##### RestlessAPI

        - 一个接口只能做一个操作

      - 一般只用get/post

    - ##### RestfulAPI

      - 一个url作为唯一资源

      - 对于同url可以通过不同类型请求来做CRUD四种操作

        - GET/POST/DELETE/PUT

  

  

  - #### AJAX请求

    #####　xhr+promise建议封装

      ```js
      function ajax(url){
          return new Promise((reslove,reject)=>{
              //创建一个xhr对象
              const xhr  = new XHLHttpRequest()
              //初始化异步请求
              xhr.open('GET',url,true)
              //绑定状态改变的监听
              xhr.onreadystatechange = function(){
                  //ajax引擎得到响应数据后判断readyState属性
                  if(xhr.readyState!==4){
                      //请求尚未结束
                      return 
                  }
                  //判断响应码200为成功
                  if(xhr.state>=200 && xhr.status<=299){
                      resolve(JSON.parse(xhr.responseText))
                  }else{
                      //请求失败
                      reject(new Error('request error' + request.status))
                  }
              }
              xhr.send()
          })
      }
      ```

      - ##### http和ajax请求异同

        - ajax是一种特别的http请求,一般请求会直接显示响应体数据导致刷新/跳转页面
        - ajax引擎不会对界面进行任何操作,会将数据保存到特定的xhr对象上,并调用onReadyStateChange监听回调

      - ##### xhr.status响应状态码

        - 2xx:成功处理请求
        - 3XX:重定向  304协商缓存
        - 4XX:客户端请求错误   401TOKEN过期/未授权  404资源不存在
        - 5XX:服务端错误

    - #### axios

      - ##### 请求参数

        - ##### params参数拼路径

        - ##### query参数?query1=666&query2=888

        - ##### body参数json格式:{" user":"ahanve","pwd":"123"}

        - ##### header参数token:123

      - ##### 基本格式

        ```js
        //伪代码实现
        //产生一个val为config对象的成功promise
        function axios(config){
            return Promise.resolve(config)
        }
        
        	//请求拦截器回调
            axios(configObj).then(config=>{
            return config
        })
        
        	//发AJAX异步请求
            .then(res=>{
            //根据config对象构建XHR对象,发送异步AJAX请求
            xhr
            //如果请求成功封装好响应数据
            const response = {
                data:JSON.parse(xhr.responseText),
                status:xhr.status
            }
            resolve(response)
            //如果失败
            reject(new Error("错误信息"))
        })
        
        //响应拦截器回调
        .then(res=>{
            return res.data
        },err=>{
            throw err
        })
        ```

      - ##### 封装

        ```js
        //封装
        const service = axios.create({
        	baseUrl:'/api',
            timeout:30000
        })
        //请求拦截器
        service.interceptors.request.use(config=>{
            //添加请求头
            config.headers.user = 'ahanve'
            const token = localStorage.getItem("token")
        	if(token){
                config.headers.token = token
            }else{
                router.replace("/login")
                message.error("没有权限")
            }
            return config
        })
        //响应拦截器
        service.interceptors.response.use(res=>{
            return res.data
        },err=>{
            //thorow err
            const {response} = err 
            if(response && response.status){
                if(response.status===401){
                    if(router.currentRoute.path!=='/login'){
                        router.replace('/login')
                        message.error('登录已过期,请重新登录')
                    }
                }else{
                    message.error('请求出错':err.message)
                }
            }else if (!response){
                //网络连接不上
                message.error('网络异常,无法连接服务器')
            }
            //将错误向下传递
            return Promise.reject(err)
        })
        
        export default service
        
        //使用
        import request from './service'
        request({url,method,params,data,headers}).then(res=>{}).catch(err=>{})
        ```

  

  

  - ### 内存管理

    - #### 生命周期

      - ##### 分配

        定义变量/创建对象/调用函数

      - ##### 使用

        读取/设置/计算

      - ##### 释放

        在单独一个线程执行的垃圾回收器,每隔一段时间会释放一次所有不能访问到的对象所占用的内存

        ##### 垃圾回收机制判断

        - 引用计数法(过时)

          ```js
          var a = {} // count = 1
          var b = a //count = 2
          a = null //count = 1
          b = null //count = 0 时此对象即判为垃圾对象
          
          //嵌套引用问题
          var a = {}  // count1 = 1
          var b = {} // count2 = 1
          a.x = b // count2 = 2
          b.x = a // count1 = 2
          
          a = null // count1 = 1
          b = null // count2 = 1
          ```

          

        - 标记清除法

          从根对象window开始查找所有被引用的对象,并标记为"使用中"

          ```js
          var a = {}  // 1使用中
          var b = {} // 2使用中
          a.x = b // 1使用中
          b.x = a // 2使用中
          a = null // window上无法找到清除标记1
          b = null // window上无法找到清除标记2
          ```

          

    - #### 内存泄漏/溢出

      - ##### 泄漏

        当程序中某个内存数据不再使用,但由于某原因未被释放

        - 意外的全局变量
        - 未清除的定时器
        - 未清除的监听
        - 未释放的闭包

      - ##### 溢出

        内存泄漏容易造成内存溢出,

        递归死循环爆栈:reduce方法

        大对象循环引用:数组循环添加

  

  

  - ### BOM

    - #### window对象

      ```js
      moveBy(x,y)水平垂直移动窗体
      moveTo(x,y)相对于左上角移动窗体
      resizeBy(w,h)相对当前窗体大小扩大/缩小
      resizeTo(w,h)相对窗体宽度大小扩大/缩小
      scrollTo(x,y)相对于窗体滚动条移动
      scrollBy(x,y)横纵向移动固定px
      window.open()打开一个新窗口跳转
      window.close()关闭新窗口
      ```

    - #### location

      ```js
      location.href="url"//跳转页面
      location.reload//刷新当前页
      location.search()//获取查询字符串
      ```

    - #### navigator(浏览器属性)

    - #### screen(屏幕属性)

      ```
      screen.width/height屏幕像素宽高度
      ```

    - #### history

      ```
      history.go(url/0刷/-1返/1进)//跳转页面
      history.forward()//前跳
      history.back()//后跳
      ```

      

      

  - ### DOM

    - #### 操作

      - 增删改查

        ```js
        //增
        const div = document.createElement('div')
        //只存内存不进页面的文档碎片
        const fragment = document.createDocumentFragment()
        p.appendChild(div)
        p.setAttribute('class','red')
        
        //删(节点虽然不在DOM树上,但div仍在内存中)
        p.removeChild(div)
        
        //改
        p.innerHTML=``
        p.style.color = 'red'
        
        //查
        document.querySelector('./#/div').parentNode().childNodes()
        document.querySelectorAll('div')
        document.getElementById/getElementByClassName/getElementByTagName/getElementByName('')
        ```

        

    - #### 事件

      - ##### 事件传播流程

        捕获阶段:嵌套结构由外向内依次处理

        目标元素处理

        冒泡阶段:由内向外依次处理

      - ##### 事件委托

        基于DOM树结构,事件在目标元素上处理后会逐层传递给所有外层元素

        应用:多个子元素需要绑定相同的事件,就可直接绑给他们的父元素减少内存占用监听个数

        ui/li列表可以通过给ul绑定点击监听后期动态添加的li也可以响应,然后通过event.target拿到目标元素信息

​    



- ## TS

  - ### 和JS异同

    - TS是强类型语言但不同于java必须,不用运行和插件检查即时在编写时得到更友好的代码提示和补全功能
    - TS是JS的超集,支持所有语法的同时也扩展了一些新的数据类型:联合类型,元组,枚举,接口,泛型,别名
    - TS不可直接运行在浏览器,需要编译为JS
    
  - ### TS新语法
  
    - #### 接口
  
      - 对属性和方法的抽象描述
  
      - 用来约束对象/函数/类
  
        ```ts
        interface xxx{
            a:string,
            test(a:number):void
        }	
        ```
  
    - #### 泛型
  
      - 用来指代暂不确定且多处使用的类型
  
      - 泛型用在函数/接口/类上
  
        ```ts
        function createArr<T>(count:number,val:T):T[]{
            const arr:T[] = []
            for(let i=0;i<count;i++){
                arr.push(val)
            }
            return arr
        }
        createArr<string>(3,"han") 
        ```
  
    - #### 类型别名
  
      - 给特定的值或类型指定别名,以之后简洁复用
  
        ```ts
        //值别名
        let status:0|1|2 = 2
        
        type Status = 0|1|2
        let status2:Status = 2
        
        //类型别名
        type Type = string | number
        let a:Type = 'han'
        a = 123
        
        //接口组合别名
        interface Person{
            name:string,
            age:number
        }
        type Persons = Person[]
        let person1 = [
            {
                name:"han",
                age:99
            },
            {
                name:'wei',
                age:66
            }
        ]
        ```
  
      - ##### typeof在TS和JS的不同场景
  
        ```ts
        //JS
        log(typeof 2)
        //TS
        function fn(x:number):string{
            return x + 'han'
        }
        let my:typeof fn = (val:number):string=>{
            return val.toString()
        }
        ```
  
        
  











- ## Vue2

  - #### MVVM模式

    - #### MVC后台架构

      ![MVC后台架构](C:\Users\ahanv\Desktop\java\MVC后台架构.png)

      controller控制器(后台路由)接收用户输入的指令和数据请求,model业务模型(类对象)对指令数据进行逻辑判断和数据库做交互处理数据,view视图(ejs)根据业务逻辑选择不同模版渲染数据展示给用户

    - #### MVVM

      M:model模型就是存储数据的js对象,对应vue就是data对象

      V:view视图就是DOM和css组成的渲染树,对应vue就是模版页面

      VM:VewModel视图模型就是数据和页面的双向绑定,对应就是vue组件实例






  - ### Vue2响应式

    - #### 常见

      - ##### data为什么是函数返回

        - 同一组件的多个实例data必须是不同地址引用的对象,否则会联动同一对象
        - data如果是函数,组件实例通过调用每次可得到一个新data对象

      - ##### 响应式数据

        data/props/computed/vuex的state和getters

        订阅发布机制:observer/dep/watcher

        ##### React和Vue区别

        - vue:通过defineProperty()/Proxy代理flect反射监视数据变化
        - react:统一定义更新数据的函数setState()/函数组件setXXX()

      - ##### vue2对象和数组响应式差别

        因为数组中数据太多,如果要绑定响应需要太多性能损耗严重

        - 对象:通过Object.defineProperty()的getter和setter方法来监视数据的改变+发布订阅....由于setter只能监视原有属性的修改局限了definedProperty不能直接增删属性所以才有$set和$delete方法
        - 数组:重新更新数组的七个方法+订阅发布:pop/push/shift/unshift/sort/reverse/splice...首先原生方法去更新数组,然后render界面

      - ##### 非响应式(模版可读取但改变不会触发render视图更新)

        - 给组件对象直接添加新属性:this.xxx = val

        - 给响应式对象添加一个新属性:this.pro.xxx = val => this.$set(this.pro,"xxx",val)
        
          
        
      - #### 响应式原理

        ![vue初始化](C:\Users\ahanv\Desktop\java\vue初始化.png)

        - ##### 数据代理

          - 用于简化读写代码: this._data.xxx = val  => this.xxx = val
          - 通过给vm以及递归data对象中属性,添加getter去读取_data对象中的属性,和setter方法去响应然后写入到data对象对应属性中

        - ##### 数据劫持

          - 监视到data对象中任意层级属性的更新

          - 通过defineProperty来修改data中的属性,给属性添加getter来收集依赖userwatcher到deps数组=>通过setter来响应修改并通过dep.notify()递归调用派发更新updateComponent

            

        - ##### 依赖收集(初始化)和派发更新(数据改变)

          - ##### 初始化

            - 初始化data时,通过递归给data所有层次属性都通过defineProperty添加getter读取计算和setter监听改变
            - 同时属性内部会创建一个dep对象,用于收集此属性的watcher依赖,接着创建不同类型的watcher(每个属性都至少创建一个渲染watcher)
            - 当读取data数据时会执行对应的getter回调,将dep.depend({})将所有依赖watcher推入subs队列数组(渲染watcher每个属性都有)

          - ##### 更新

            - 更新了data中某个数据,setter会截取到改变调用dep.notify()遍历调用所有dep.subs数组中的watcher回调
              - 遇到计算wathcer=>将watcher中的dirty:true,最终在渲染watcher执行render()时执行
              - 遇到自定义watcher/渲染watcher=>quequeWatcher(wath)将watcher回调推入队列准备异步执行(内部利用nexttick)
              
            - ##### nextTick()实现异步DOM更新
            
              ![nexttick内部运行](C:\Users\ahanv\Desktop\java\nexttick内部运行.png)

              - 内部有一个queue数组保存要执行的自定义/渲染watcher...内部定义一个flushQueue函数,遍历调用所有的watcher,如果是自定义watcher执行回调,如果是渲染watcher就调用updateComponent去更新DOM
          
                ##### 当更新data数据或手动nexttick()时
          
                - 初始化
          
                  会将对应的自定义/渲染watcher推入到queue数组中,通过flushQueue函数内部通过promise.then()将更新DOM的回调推入到callbacks队列中,
          
                - 更新data
          
                  通过queueWatcher函数,将新watcher推入到queue数组队列
          
                - 手动调nextTick(cb)
          
                  直接将cb推入到callbacks队列中
          
              - 通过flushCallbacks函数,遍历callbacks队列数组..内部优先微队列其次宏队列,利用promise.resolve().then(watcher函数)依次执行更新DOM的回调
          
              - 通过pending判断,第一次调用callback更新DOM回调时用定时器推入宏队列中
          
            - 遍历所有依赖的wathcer回调,subs[i].update()做更新操作
            - 依次判断是否为计算watcher,若不是推入到渲染队列queueWathcer(this),watcher内部遍历调用nextTick,watcher.run(),然后进行this.user标识判断
              
              - 如果是自定义wathcer则调用自己写的回调,若为渲染watcher则调用vm.update(vm.render())
            - 此时若有计算属性会执行计算watcher判断dirty,决定走缓存还是调用getter计算得到最新的数据值
            
          
        
      - ##### 三种watcher
        
        - ##### 用户user watcher(user:true)
        
          - 每次配置watch或调用$watch时,会创建一个user:true的watcher..
        
          - 如果传入的option配置对象中immediate:true,初始化时会立即调用一次watcher回调
        
            如果deep:true,会对引用类型数据进行递归依赖收集
        
            - 自定义watcher回调先于渲染watcher执行,所以只能拿到旧DOM需要$nexttick()/$set()/$forUpdate()再触发一次渲染
        
            
        
          - ##### 渲染render watcher(isRenderWatcher:true)
        
            - 专门用于组件DOM的初始化/更新渲染,每个组件仅有一个..
        
            - 在初始化准备挂载组件时,创建render watcher并指定updateComponent回调,在组件数据变化后来异步执行(生成虚拟DOM=>生成真实DOM)
        
            - 在new Watcher()会传入vm组件和updateComponent回调,配置对象options和,最后一个标识参数true
        
              
        
          - ##### 计算computed watcher(lazy:true),在渲染wathcer中执行
        
            - 每设置一个component属性,会创建对应的computed watcher,通过defineProperty和两个标识lazy/dirty实现劫持和缓存
        - 初始化时同步执行更新时异步执行watcher回调,默认lazy:true和dirty:true...即初始时不会调用getter进行计算,并将所有dirty:true..
          
            - 懒计算:每次render渲染读取计算属性时会调用getter进行计算然后将diry:false..下次getter读取时不会重新调用getter来计算
        - 计算缓存:每次依赖属性变化时会通过setter截取将dirty:true,以下次读取时会进行重新getter计算...从而做到缓存效果
        
        
      
      - #### keep-alive组件

      - 包裹的组件会执行activated在初始mounted之后和每次切回时执行

        deactivated在每次组件切走时执行

        - create中

          声明一个对象放缓存的组件实例chaches:{组件1:VM1,组件2:VM2},声明一个位置映射的数组keys:['组件1','组件2']

        - render(){}中

          - 取出默认插槽中的虚拟DOM,然后去缓存对象中比对若存在不用再创建组件实例,直接赋给当前vnode删除缓存数组中的key,并重新push添加到标识数组右边
    - 若没有缓存暂存到this上,然后通过mounted的cacheVNode方法中做缓存
          - 返回vnode渲染

        - mounted/updated => cacheVNode(){}

          - 将当前vnode组件实例对象缓存到chache对象中,将对应的key保存到keys数组最右边
        - 如果缓存数超过了props传入的最大值,通过$destory()销毁对应的缓存组件实例和keys数组中第一个key
          
      - LRU算法
        
      - 最近最少使用
          - 通过keys数组映射控制:最近用的放在数组最后,保持第一个用的最少
      
      

    

  - ### 初始化

    ![new Vue初始化流程](C:\Users\ahanv\Desktop\java\new Vue初始化流程.png)

    

    - ##### Runtime+Compiler(模版编译器) :

      - vue-cli创建项目默认引入的是不含compiler版本的vue.js
      - vue组件中的template模版是webpack打包时,vue-loader对其编译为的render函数

      ```js
      import App from './App.vue'
      import Vue from 'vue'
      new Vue({
          render:function(createElement){
              //1,使用h函数创建虚拟DOM
              const res = createElement(App)
              return res
              //2,使用模版字符串
              const vNode = `<div>111</div>`
              return vNode
          }
          //3,webpack打包时vue-loader对其编译为的render函数,若自己运行需要改变vue引入路径文件
          template:`<App></App>`,
          componetns:{
          App
      	}
      }).$mount("#app")
      ```

    - 没有编译器版本的vue需要配置vue-esm.js

      ```js
      const {resolve} = require('path')
      module.exports = {
          lintOnSave:false,
          configureWebpack:{
              resolve:{
                  extensions:['.js','.vue','.json'],//引入那些文件省略后缀
                  modules:[resolve(__dirname,'src'),'node_modules'],//引入模块包
                  alias:{
                      //import Vue from 'vue'的路径修改
                      "vueZ$":"vue/dist/vue.esm.js",
                      '@':resolve('src')
                  }
              }
          }
      }
      ```

    - ##### 模版编译流程(Compiler)

      - 通过解析模版字符串生成抽象语法树AST对象(打断点就能看到tag标签名attrs属性数children子节点数组 )

      - 遍历AST语法树中的atrrs和children数组中的节点,添加静态标识属性static:true,为后面虚拟DOM和DIFF算法生成动态节点做准备..

      - 根据AST对象生成虚拟DOM的render函数代码

        "with(this){return _c("div",{attr:[]})}"  vm.__C去调用createElement()创建虚拟DOM
        
        

    - ##### new Vue()做了什么

      - ##### 之前

        在new Vue前先初始化全局API添加到Vue.prototype原型上initGlobalAPI(),将_init,$set和$on/$emit和$nextTick和componet方法

      - ##### 进行中

        - Vue.prototype._init方法去创建$createElement和__c渲染生成Vnode

        - 创建beforeCreate:callHook(vm,'beforeCreate',undedined,false)

        - ##### initState(vm)初始化data,props,methods,computed,watch

          - 通过vm代理对prop属性操作
            - 利用defineProperty给vm添加Props属性并代理操作

          - 将methods的方法添加vm上
            - 将methods中的方法添加到vm上,并通过bind来修改方法中的this到vm上
          - 将data添加到vm的_data上,通过defineProperty和递归绑定消息订阅发布(Observer/dep/watcher)实现data所有层次的响应式处理
          - computed:利用defineProperty定义getter/setter
            - 然后创建计算属性watcher=>.lazy=true标识懒计算(数据改变了只有读取时才会计算)...
            - 然后调用$watch方法创建自定义watcher,此时若配置了immediate就会立即执行被监视的回调,
          - watch:创建一个自定义watcher=>.user=true

        - 调用created钩子,如果有el配置调用$mount方法挂载到el对应的元素上

          - vm.$mount(vm,$options.el)
            - 先判断Vue是否带编译器,有则编译options.template生成render函数添加到options上...没有就检查有无render没有或有template就报错

        - 调用beforeMount钩子(Vnode尚未生成).....

          - 定义初始化/更新组件的函数updateComponent
          - 创建渲染watcher时会传入调用updateComponent,先调用vm._render()生成虚拟DOM
          - _.__update()内部patch()生成/更新真实DOM,调用vm._-c()渲染模版,挂载到el上

          ```js
          updateComponent=funtion(){
          	vm._update(vm._render(),hydrating)
          }
          ```

        - 调用mounted钩子

      

      - ##### 虚拟DOM

        ```js
        new Vue({
        	render:h=>{
        		const vnode = h("div",//tag
                	{
                    	attrs:{id:'root',name:"xxx"}
                	},//data
                    [
                    	h('p',{},'hello'),
                    	h('span',{},'world')
                	]
               	)
                console.log(vnode)
        	}
        })
        ```

        

        VNode类设计目的是:只用操作更新数据不用操作真实DOM,为了DOM最小化更新所以vue内部设计了VDOM的DIFF处理(初始化变慢,更新更快)

        - 一个VNode实例对象包含了生成真实DOM的重要信息数据:tag标签名,data属性数组,children子节点数组,key标识

        - 初始化阶段会根据虚拟DOM对象生成真实DOM

        - 更新阶段会进行新旧虚拟DOM的DIFF算法比较,来更新真DOM

          

      - ##### Diff差异算法

        - ##### key的深入理解

          - key是虚拟节点的表示,只有找到相同key和tag标签名的旧虚拟DOM才能复用旧真实DOM
          - 保证虚拟DOM的key的唯一性和稳定性,才能确保真实DOM的复用
          - 用数组下标作为key的不稳定问题:每当数组列表新增/删除/乱序后,key会出现比对错乱复用错误的真实DOM和按Index依次更新(位置影响了key值)

        - 同层比较找出key和tag都相同的vnode节点对象,若找到了复用到真实DOM中

        - 期间若有数据变化watcher监听到会更新真实DOM,如果没有找到则根据最新的虚拟DOM创建真实DOM

          ##### patch()更新内部调用updateChildren()

        - 第一次调用patch(el,vnode)=>根据vnode生成node,替换el(id=app)

        - 之后调用:patch(oldVnode,vnode)=>新旧VDom的diff比较,最小化更新真实DOM

          ##### 差异比较函数updateChildren(){}

          ![双指针四比较DIFF](C:\Users\ahanv\Desktop\java\双指针四比较DIFF.png)

          - 双指针:新旧开始/结束下标4个变量
          - 四对顺序if/else if/ else都无时走乱序:
            - 首尾:新前=>旧前,新后=>旧后
            - 交叉:新后=>旧前,新前=>旧后
          - 偏移指针:
            - 若tag和key不同则将新VDOM塞入旧VDOM中
            - 若相同则复用后前inde+1后index-1
          - 更新规则:
            
            - 如果旧前/旧后index重合,而新前/新后Index尚未重合则添加DOM,反之为删除DOM
          - ##### 乱序比对:

            - 创建一个剩余key与旧vnode下标的映射对象,
            - 根据新前newStartNode的key去映射对象匹配对应的vnode
            - 然后while循环index+1指针下移继续去映射对象匹配



- ### 其他

- #### 单例模式

  首次创建实例对象将其保存到构造函数上,之后再new永远返回第一次保存的实例对象

  ```js
  function Single(name){
  	if(Single._instance){
          return 	Single._instance
      }
      this.name = name
      Single._instance = this
  }
  const s1 = new Single('s1')
  const s2 = new Single('s2')
  log(s1===s2)//true
  
  //通过构造函数的静态方法
  function Single2(name){
      this.name = name
  }
  Single2.getInstance = function(name){
      if(this._instance){
          return this._instance
      }
      return (this._instance = new Single2())
  }
  
  //柯里化+闭包做通用工具函数
  function singleton(Type){
      let instance
      return function(...args){
          if(instance) return  instance
          return instance = new Type(...args)
      }
  }
  function Person(name,age){
      this.name = name
      this.age = age
  }
  const People = singleton(Person)
  const p1 = new People('A',99)
  const p1 = new People('B',66)
  ```

  

- #### 工厂模式(render钩子也算)

  调用函数通过不同参数,创建特定类型的实例对象

  ```js 
  function factory(role){
      function User(opt){
          this.name = opt.name
          this.viewPages = options.viewPages
      }
      switch(role){
          case "superAdmin":
              return new User({
                  name:"superAdmin",
                  viewPages:['home','my','shop']
              })
              break;
          case "admin":
              return new User({
                  name:"superAdmin",
                  viewPages:['home','my']    
              })
              break;
          default:
              throw new Error('暂无角色')
      }
  }
  let superAdmin = factory('superAdmin')
  ```

  

- #### 大文件上传(切片上传)

  - ##### 通过FormData将文件切分成多次请求的小文件

    ```js
    function update(file){
    	const hash = await getHash(file)
        //得到文件下标
        const pointIndex = file.name.lastIndexOf('.')
        //按时间命名
        const filename = file.name.slice(0,pointIndex) +new Date().getTime() + file.name.slice(pointIndex)
       	//单位小文件大小
        const shareSize = 2 * 1024 * 1024
    	//总大小
        const size = file.size
        //小文件个数
        const total = Math.ceil(size/shareSize)
        //初始化小文件下标
        let index = 0
        //执行
        upload()
        
        
        async function upload(){
            //开始
            let start = index * shareSize
            //结束
            let end = (index+1)*shareSize>size ? size :(index+1)*shareSize
            //得到文件中对应位置的数据
            const data = file.slice(start,end)
            const formData = new FormData()
            formData.append('hash',hash)
            formData.append('total',total)
            formData.append('hash',hash)
            formData.append('hash',hash)
            formData.append('hash',hash)
            formData.append('hash',hash)
            
            //通过axios发请求
            const res = await axios.post('/uploadXXX',formData)
            index ++ 
            if(index<total){
              //递归发送
                upload()
          }else {
                log('upload success',res.url)
          }
        }
  }
    ```

    

- #### websocket

  - H5新出的协议除了IE都支持..支持浏览器和服务端双向通信,用于HTTP轮询

  - 一般不用原生而用包装库socket.io

  - 服务端(node)

    ```js
    const app = require('express')()
    const http = require('http').createServer(app)
    const io = require('socket.io')(http)
    //绑定链接监听,在回调中得到与客户端链接对象
    io.on('connection',function(socket){
        //绑定消息监听,接收客户端消息
  	socket.on('消息名(sendMsg)',function(data){})
        //向客户端发送消息
  	socket.emit('消息名(backMsg)',data)
    })
    
    
    
    ```

  - 客户端

  ```js
    //链接ws服务器地址,得到链接对象
    socket = io('ws://localhost:4000')
    //绑定接收消息的监听
    socket.on('消息名(backMsg)',function(data){})
    //分发消息
    socket.emit('消息名(sendMsg)',data)
  ```

    





- ## Vue3

  - ### Vue3新特性

    - 以业务逻辑组合代码块compositionAPI,不按data/methods功能组织optionAPI.

    - 可复用性:
      
      - 用Hooks取代mixin,可以按功能引入阅读性更高
      
    - 体积更小:
      - 引入treeShaking在打包压缩时将无用模块筛除
      - 对vue库进行按需引入打包
      
    - 性能更好
      - 数据响应用Proxy代替defineProperty来实现监视劫持,以属性为单位取代以对象为单位
      - diff算法优化:静态虚拟DOM添加静态标记,略过diff比较直接复用对应的真实DOM
      - 静态提升:静态虚拟DOM提升到render外缓存,不重新创建
      
    - 对TS类型检查,pinia数仓,vite脚手架等新工具有更好的支持

      

  - ### CompositionAPI的异同

    - #### setup函数

      - setup钩子在beforeCreate前调用

      - 创建组件实例,并初始化props

        

    - #### ref(基础类型)/reactive(引用类型)

      - ##### Ref

        - ref(2)返回一个ref对象并通过.value访问和修改,如果传入引用类型也会通过给.value包裹reactive标为proxy对象
        - 模版中可以省略.value,因为模版编译会解析判断但js编译时babel不行
        - ref响应式通过defineProperty的get和set来监视拦截

      - ##### reactive

        - reactive({})传入一个普通对象返回一个深度监视的proxy对象

        - proxy通过Proxy代理监听和Reflect反射操作

          

    - #### toRefs()

      - 从proxy对象解构出来的属性是非响应式的,用toRefs()可以快速将普通属性转为ref属性

        ```js
        const state = reactive({on:1,off:0})
        //const {on,off} = state
        const {on,off} = toRefs(state)
        on.value = 2
        ```

        

    - #### watch

      - 监视一个ref

        ``` js
        watch(count,(newVal,oldVal)=>{
            log('count变化了')
        })
        ```

      - 监视reactive某个属性

        ```js
        watch(()=>state.on,val=>{
            log('state中的on变了')
        })
        ```

      - 监视多个响应式数据

        ```js
        watch([count,()=>state.on],valArr=>{
            log('count或state.on变了')
        },{deep:true,immediate:true})
        ```

        

    - #### computed

      - 只用getter

        ```js
        const count = ref(2)
        const double = computed(()=>{
            return count.value*2
        })
        ```

      - getter/setter

        ```js
        const count = ref(2)
        const double = computed(
        	{
                get(){
                  return count.value*2 
                },
                set(val){
                    count.value = value/2
                }
            }
        )
        ```

        

    - #### 生命周期

      - beforeCreate/created被setup代替

      - 其余钩子前加on作为函数调用

      - 销毁钩子改名为onBeforeUnmount/onUnmounted(()=>{})

        

    - #### 路由(Router V4)

      - ##### 创建路由

        - new Router变为createRouter
        - createWebHistory()与createWebHashHistory()取代mode:'history'和hash..避免了两种模式都打包

      - ##### 动态添加路由

        - 一次添加多个变为一次一个router.addRoute(route)

      - ##### 通配路由的path

        - path:*变为path:/:pathMatch(.**)

          ``` js
          import {createRouter,createWebHistory} from 'vue-router'
          import routers from './routes'
          
          const router = createRouter({
              history:createWebHistory(),
              routes:routes,
          })
          
          export default router
          ```

          

    - #### 组件通信

      - ##### props

        ```ts
        interface Props{
            count:number,
            fun(name:string):void
        }
        const props = defineProps<Props>()
        ```

      - ##### 自定义事件

        ```ts
        <Btn @click='test'/> //如果子组件没有声明接收即为原生事件
        interface Emit{
            (e:'click',val:object):void
        }
        const emit = defineEmits<Emit>()
        //分发传参
        emit('click',{name:'han'})
        ```

      - ##### 全局事件总线

        因删除了$on需要引入第三方库:mitt或者pubsub-js

        ```js
        //监听
        onMounted(()=>{
            PubSub.subscribe('updateBro',(msgName,data)=>{
                log(data)//666
            })
        })
        
        //分发
        @click="PubSub.publish('updateBro','666')"
        
        //解绑
        onBeforeUnmount(()=>{
            PubSub.unsubscribe('updateBro')
        })
        ```

      - ##### v-model

        - 底层实现变化没了.sync直接可绑定多个v-model

          ```js
          //原生input
          <input type="text" :value="msg" @input="msg=($event.target as HTMLInputElement)" />
          //组件标签
          <Son v-model:Myname="msg1">
          <Son :modelValue='msg1' @update:modelValue="msg1=$event" />
          ```

      - ##### $ref/$parent

        ```ts
        //父
        <Son ref=''/>
        const sonRef = ref<InstanceType<typeof Son> | null>(null)
        const click = sonRef.value.borrow(99)
        //子
        const money = ref(0)
        const borrow=(num:number)=>{
            money.value+=num
        }
        //定义向外暴露的属性方法
        defineExpose({
            borrow,
            money
        })
        ```

        

    - #### 数仓vuex与pinia

      - pinia没有mutations,在actions中可以直接同步/异步更新state

      - pinia中可以有多个相互独立且不合并的store

      - 无需手动注册store,直接引入创建

        main.js

      ```js 
      import {createPinia} from 'pinia'
      import {createApp} from 'vue'
      
      import App from './App.vue'
      import router from './router'
      
      const app = createApp(App)
      app.use(createPinina()).use(router).mount('#app')
      ```

      store.js

      ```js
      import {defineStore} from 'pinia'
      
      export const useCounterStore = defineStore({
          id:"counter",
          state:()=>({
              counter:0
          }),
          getters:{
              doubleCount:(state)=>state.counter*2
          },
       	actions:{
              add(){
                  this.counter++
              }
          }
      })
      ```

      app.vue

      ```js
      <template>
      	<div>{count}</div>
      </template>
      
      <script lang='ts' setup>
      import {storeToRefs} from 'pinia'
      import {useCounterStore} from './store.js'
      
      const counterStore = useCounterStore()
      const {count,doubleCount} = storeToRefs(counterStore)
      counterStore.add()
      log(doubleCount)//2
      </script>
      ```

      

  

  

  - ### 响应式伪源码(虚拟DOM即后vnode或vmDom)

    - #### vue3与vue2响应式区别(Proxy/Reflect取代Observer/Dep)

      - vue2中对象以属性为单位通过defineProperty的set/get对已有属性进行读取和修改监视,数组通过重写pop/push/shift/unshift/sort/reverse/splice七个方法
      - vue2响应式问题在于直接对对象新增/删除,defineProperty监视不到界面不会更新.数组通过下标的替换/添加同样
      - vue3对基础数据沿用defineProperty通过对value属性的监视,引用类型以对象为单位使用Proxy代理以监视增删改查,并通过Reflect反射动态操作代理对象
      - vue3对象直接添加/删除属性可以监视到,通过一个代理对象监视所有属性的操作
    
    - ##### 数据基础数据ref()的get和set,RefImpl对象(defineProperty)
    
      ```js
      const isObj = val=>val!== null && typeof val === 'object'
      //判断传入的数据是否为引用类型,是则走reactive
      const convert = val = >isObj(val)?reactive(val):val
      class RefImpl{
      	constructor(value){
              //保存构造数据
              this._rawValue = value
              //ref对象标识
              this._v_isRef = true
              //判断保存新数据
              this._value = convert(value)
          }
          get value(){
              //追踪依赖
              track(this,"value")
              return this._value
          }
          set value(newVal){
              if(newVal !== this._rawValue){
                 this._rawValue = newVal 
                this._value =  convert(newVal)
                 //触发依赖
                 trigger(this,"value")
              }
          }
      }
    
      export function ref(value){
        if(isObj(value) && value.__v_isRef) return value
          return new RefImpl(value)
    }
      const count = ref(2)  // => const count = new RefImpl(2)
      ```
    
      
    
    - ##### 引用类型reactive()的proxy和reflect,返回一个Proxy代理对象
    
      ```js
      const isObj = val=>val!== null && typeof val === 'object'
      const target = {
          name:'han',
          age:26
      }
      const handler = {
          get(target,key,receiver){
              //追踪依赖
              track(target,key)
              const res =  Reflect.get(target,key,receiver)
              //判读读取值是否为对象
              return isObj(res)?reactive(res):res
          },
          set(target,key,value,receiver){
              const oldVal = Reflect.get(target,key,receiver)
              let res = true
              if(oldVal !== value){
                  //新值和旧值不相等,再写入
                const res = Reflect.set(target,key,value,receiver)
              }
              if(res){
                  //触发依赖
                  trigger(target,key)
              }
             return res
          },
          deleteProperty(target,key){
              //判断目标对象上是否有此属性key
             const res =  target.hasOwnProperty(key) &&　Reflect.deleteProperty(target,key)
              if(res){
                  //触发依赖
                 trigger(target,key)
              }
            return res
          }
        return new Proxy(target,handler)
      }
    
      const proxy = new Proxy(target,handler)
      ```
    
      
    
    - ### Effect函数更新DOM(取代Vue2的三种Watcher)
    
      ```js
      import {reactive,effect,ref} from 'vue'
      const states = reactive({
        name:'han'
      })
    effect(function effect(){
          //副作用函数
        document.getElementById('name').innerHTML = states.name
      })
      ```

    - #### 纯函数和副作用函数

      - ##### 纯函数
    
      - 函数执行结果只依赖于传入的参数,多次调用结果都相同
  
- 函数不能读取或更新外部数据
  
- ##### 副作用
  
        - 函数执行/结果依赖于外部数据的变化
      - 函数内部可以读取/修改外部数据
    
    
    
    ![](C:\Users\ahanv\Desktop\java\vue3原理图.png)
    
  - #### get添加依赖track(target,key)=>new WeakMap      
    
    - 保存此次activeEffect回调,因读取数据会触发getter方法内部tract()追踪依赖,
      - 方法内部会创建一个依赖桶:new WeakMap(可被垃圾回收的弱类型)
    - 如果没有传入activeEffect函数直接return结束,如果有会targetMap.get(target)取目标对象属性和回调队列的depsMap对象,没有则new Map创建一个depsMap对象
      - depsMap.get(key)取目标对象各属性对应的回调队列,没有就new Set(用Set可自动取重)创建一个dep数组
      - 将当前effect回调dep.add(activeEffect)存入队列中,以待数据改变setter时遍历trigger()触发
    
  - #### set触发依赖trigger(target,key)
    
    ##### targetMap.get(target).depsMap.get(key).forEach(effect=>effect())
    
      - 先从targetMap.get(target)取对应的depsMap
      - 如果有就从depsMap.get(key)取对应属性名的dep回调队列
      - 如果有则dep.forEach()遍历调用更新DOM
    
      ##### ref同理触发value的getter和setter方法添加和触发effect依赖,只是传参变为(ref对象,"value")
    
    
    





- ## React

  - ### 和vue异同

    - #### Diff算法和key,与vue一样

    - #### SetState()和vue的DOM更新queue队列存放所有wathcer调用

    - #### 生命周期,思路和vue相同

      - ##### 初始化

        类组件:construtor=>componentWillMount=>render=>componentDidMount

        函数组件:useEffect(()=>{},[])

      - ##### 更新（forceUpdate可以强制更新不走阀门）

        类组件:阀门shouldComponentUpdate(父组件更新或调用setState时默认打开,通过return true/false来控制)=>componentWillUpdate=>render=>componentDidUpdate

        函数组件:useEffect(()=>{},[data])

      - #####　卸载

        类组件:componentWillUnmount

        函数组件:useEffect(()=>{return ()=>{}})

    - #### 缓存组件export default React.memo() 和 <keep-alive>

    - #### 无路由守卫,需要通过高阶组件进行权限校验

      

  - ### 基础

    - 看起来想html的js代码必须引入babel解析,底层通过React.createElement()创建虚拟DOM

      ```jsx
      <h3 id={title.name} style={{color:'red'}}>{title.msg}</h3>
      ```

    - 事件绑定命名为小驼峰而非原生纯小写onClick={handleClick},通过对跨平台原生事件对象的封装加环境判断,从而同一事件不同平台兼容.

    - 与vue通过对data数据的读取/更新的监视不同,react将修改数据与更新DOM的操作封装成一个工具函数:类组件:this.setState()...hooks组件:自定义名的setMsg()

    - react中props父子传参,子组件可不声明接收和约束而vue不可

  - ### 类组件=>函数组件

    return需要根标签会导致层级臃肿..可用<React.Fragment>包裹或<></>晃一下

    - #### 类组件

      ```js
      import React from 'react'
      
      class App extends React.Component{
          state={name:'wei'},
          //因类组件中开启严格模式所以render调用handle时this指向undefined,需要通过箭头函数让组件实例调用此方法
          handle = (type)=>{
              this.type===1 && this.setState({name:'han'})
              log(this.state.name)
          }
          //继承并重写render方法
          render(){
              return <div>
                  	<h3>{this.state.name}</h3>
              		<button onClick={this.handle(1)}></button>
                  </div>
          }
      
      }
      ReactDom.render(<App/>,document.getElementById('root'))
      ```

      

    - #### 函数组件(react16出现Hooks语法17可修改状态后开始普及=>Vue3借鉴)

      父组件集中管理状态和操作逻辑,子组件只负责props接收更新则称其为受控组件

    - ##### 生命周期

      ![react生命周期](C:\Users\ahanv\Desktop\java\react生命周期.png)

    - ##### hooks语法

      - useState()定义和更新状态数据 => vue3中的ref()/reactive()
      - useEffect()用于监视数据变化,并模拟类组件中的compoenentDIdMount/componentUpdate/componentWillUnmount钩子 => Vue3的watch('属性',(newVal)=>{})
      - useRef()用于获取组件中的节点DOM => 
      - useContent()用于祖组件向任意后代组件通信 => Vue的provide/inject

      ```js
      import {useState,useEffect} from 'react'
      function App(){
          //初始化数据
          const [list,setList] = useState([{name:'han',id:66}])
         	const [msg,setMsg] = useState('')
          
          //componentDidMount(){}+componentDidUpdate(){} / mounted初始 + updated
          useEffect(()=>{
              setMsg('hello')
          })
          //componentDidMount(){}+componentWillUnmount(){} / beforeDestory卸载
          useEffect(()=>{
              return ()=>{}
          },[])
         //宏任务异步更新,放外边会反复执行
          useEffect(()=>{
              setTimeOut(()=>{
                  setMsg('moto')
                  log(msg)//hello,若需要拿到最新值需要监听msg
              },3000)
          },[])
          //componentDidMount(){}+watch监视list
          useEffect(()=>{
            localStorage.setItem('listData',JSON.stringify(list))
          },[list])
      
          //方法methods
          const handlePush = (infoArr)=>{
              setList([list,...infoArr])
          }
          
          //模版JSX
          return (
          	<div>{msg}</div>
              <Son list={list} handlePush={handlePush}>
          )
      }
      
      ReactDom.render(<App/>,document.getElementById('root'))
      
      
      function Son({list,handlePush}){
          const handleAdd(){
             const infoArr = [{name:'wei',id:66},{name:'ahanve',id:11}]
             handleAdd(infoArr)
          }
          return (
          	<ul>
              	{
                      //虚拟DOM的diff算法和vue是一样的
                      list.map(item=><li key={item.id}>{item.name}</li>)
                      <button onClick={handleAdd}>点我添加</button>
                  }
              </ul>
          )
      }
      ```

    - useContext()后代通信=>通过App做子受控的全局事件总线

      ```jsx
      const context = React.createContext()
      const [msg,setMsg] = useState('')
      <context.Provider value={msg}>
          <Son/>
      </context.Provider>
          
      //后代
      function Son(){
          const msg = useContext()
          return (
              <div>{msg}</div>
          )
      }
      ```

    - ##### 路由V6

      - 和V5的变化

        - 内置组件:移除<Swith/>,新增<Routes/>等等

        - 语法变化:component={About}变为element={<About/>}

        - 新增hook:useParams,useNavigate,useRoutes

          

          ```js
          
          //入口index.jsx
          import React from 'react'
          import ReactDom from 'react-dom'
          import App from './App'
          import {BrowserRouter,HashRouter} from 'react-router-dom'
          ReactDOM.render((
              <BrowserRouter>
              	<App/>
              </BrowserRouter>
          ),document.getElementById('root'))
          //App.jsx
          import routes from './routes'
          export default function App(){
              const element = useRoutes(routes)
              return (
              	<div>{element}</div>
              )
          }
          //routes.jsx
          import {lazy,Suspense} from 'react'
          const About = lazy(()=>import('./pages/about'))
          const New = lazy(()=>import('./pages/new'))
          const routes = [
              {
                  path:'/about',
                  element:(
                  	<Suspense fallback={<h2>loading...</h2>}>
                      	<About/>
                      </Suspense>
                  ),
                  children:[
                      path:'/about/new/:id',
                      element:<New/>
                  ]
              },
              //重定向
              {
                  path:'/',
                  element:<Navigete to='/about'>
              }
          ]
          
          //子路由组件定位
          <Outlet/>
          ```

        - ##### 路由传参

          ```js
          //声明式
          <NavLink to='/about'>about</NavLink>
          //编程式
          const navigate = useNavigate()
          const handle=()=>{
              navigate('/about/new/2?title=heihei',{
                  replace:false,
                  //除了params和query还可以state传参 
                  state:{
                      name:'han'
                  }
              })
              navigate(-1)
          }
          //接参
          import {useLocation,useParams,useSearchParams} from 'react-router-dom'
          //路由信息对象
          const location = useLocation()
          const {name} = location.state
          const {title} = useSearchParams()	
          ```

      - #### 数仓redux内部实现为useContext()

      












# 微信小程序总结

### 1、请谈谈微信小程序主要目录和文件的作用？
- project.config.json：项目配置文件，用的最多的就是配置是否开启https校验
- App.js：设置一些全局的基础数据等，监听并处理小程序的生命周期函数，声明全局变量
- App.json：整个小程序的全局配置，包括：pages:[所有页面路径]，网络设置（网络超时事件），页面表现（页面注册），window：（背景色，导航样式，默认标题），底部tab等
- App.wxss：公共样式，引入iconfont等
- pages：里面包含一个个具体的页面
- index.json：配置当前页面标题和引入组件
- index.wxml：页面结构
- index.wxss：页面样式表
- index.js：页面的逻辑，请求和数据处理

### 2、请谈谈wxml与标准的html的异同？
- 都是用来描述页面的结构
- 都由标签，属性等构成
- 标签名字不一样，且小程序标签更少，单一标签更多（view为常用标签）
- 多了一些 wx:if 这样的属性以及{{}} 这样的表达式
- WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览
- 组件封装不同，WXML对组件进行了重新封装
- 小程序运行在JS Core内，没有DOM树和windiw对象，小程序中无法使用window对象和document对象。

### 3、请谈谈WXSS和CSS的异同？
- 都是用来描述页面的样子
- WXSS具有CSS大部分的特性，也做了一些扩充和修改
- WXSS新增了尺寸单位，WXSS在底层支持新的尺寸单位rpx `(1px == 2rpx)`
- WXSS提供全局样式与局部样式

### 4、你是怎么封装微信小程序的数据请求的？
- 在根目录下创建util目录及api.js文件和apiConfig.js文件
- 在apiConfig.js封装基础的get，post和put，upload等请求方法，设置请求体，带上token和异常处理等
- 在api中引入apiConfig.js封装好的请求方法.根据页面数据请求的urls，设置对应的方法并导出，在具体的页面中导入
- 或者将所有的接口放在统一的js文件中并导出
- 在app.js中创建封装请求数据的方法
- 在子页面中调用封装的请求数据

### 5、小程序页面之间有哪些（传值）传递数据的方法？
- <font color=orange>路由传参</font>：在navigator中添加参数数值（页面跳转或重定向时，使用url带参数传递数据），通过onload的param参数取值
- <font color=orange>组件传参</font>：使用组件模板 template传递参数 
- <font color=orange>缓存取值</font>：使用缓存传递参数（wx.setStorageSync wx.getStorageSync）
- <font color=orange>元素绑定传值</font>：给html元素添加data-*属性来传递值，然后通过e.currentTarget.dataset获取（data- 名称不能有大写字母，不可以存放对象）
- <font color=orange>id传值</font>：设置id 的方法标识来传值，通过e.currentTarget.id获取设置的id值，然后通过设置全局对象的方式来传递数据

### 6、小程序如何实现父子组件传参?
<font color=orange>1. 父组件给子组件传值</font>

- 父组件在引用子组件的时候通过设置属性的方式给子组件传值

```
// 在子组件中定义属性
properties: {    
  // 复杂定义    
  name:{type: String, value:'张三丰'},  
  // 简单定义   
  name2:String
},
```

<font color=orange>2. 子组件给父组件传值</font>
- 在父组件中绑定一个自定义事件

```
//父组件内容
// 引用了自定义的组件， 绑定了myevent事件，这个事件对应的是parentEvent方法
<test-button name="张无忌" bind:myevent="parentEvent"></test-button>

// 父组件内容
parentEvent(e) {
  console.log('子传父内容', e.detail)
}
```

- 在子组件中触发这个事件，可以给父组件传值。
- 子组件中通过triggerEvent触发事件

```
// 子组件内容
<button type="primary" bindtap="childEvent">给父组件传递参数</button>

methods: {    
  childEvent: function (){      
    var myEventDetail = {}
    // detail对象，提供给事件监听函数      
    var myEventOption = {} 
    // 触发事件的选项      
    this.triggerEvent('myevent', myEventDetail, myEventOption)    
  }  
}
```

### 7、⼩程序的双向绑定和vue哪⾥不⼀样？
1. 小程序中的数据双向绑定
- 首先通过 bindinput 绑定文本框的输入事件
- 在 data 中声明一个变量 content ，将其动态绑定成文本框的 value 值
- 在 bindinput 事件中通过事件参数 e.detail.value 可以获取到文本框中最新的 value 值
- 通过 this.setData 将文本框最新的  value 值 赋值给 动态绑定的value值 content  即可实现数据的双向绑定

2. vue中的数据双向绑定
- 首先为文本框绑定 @input 监听文本框的输入事件
- 为文本框动态绑定 value 属性，其值是在data中定义的变量
- 在 @input绑定的事件中 通过事件参数 event.target.value 可以获取到 input 框中最新的value值
- 将其重新获取到的 value 赋值给 value值动态绑定的那个变量

***区别：***
- 大体上区别不大，绑定事件不同，以及获取value值的具体方式不同，以及在小程序中设置data中的数据，需要调用 this.setData方法进行设置
- 在vue中进行数据绑定后,当数据修改了会直接更新到视图上，但是在小程序中呢,data数据修改是不会直接同步到,必须调用this.setData()这个方法

### 8、请谈谈小程序的生命周期函数
- onLoad()页面加载时触发，只会调用一次，可获取当前页面路径中的参数
- onShow()页面显示/切入前台时候触发，一般用来发送数据请求
- onReady()页面初次渲染完成时触发，只会调用一次，代表页面已可和视图层进行交互
- onHide()页面隐藏/切入后台时触发，如底部tab切换到其他页面或小程序切入后台等
- onUnload()页面卸载时触发，如redirectTo或navigateBack到其他页面时

### 9、⼩程序⻚⾯⽣命周期
- data：⻚⾯的初始数据
- onLoad：⽣命周期回调—监听⻚⾯加载
- onShow：⽣命周期回调—监听⻚⾯显示;
- onReady：⽣命周期回调—监听⻚⾯初次渲染完成
- onHide：⽣命周期回调—监听⻚⾯隐藏
- onUnload:⽣命周期回调—监听⻚⾯卸载
- onPullDownRefresh:监听⽤户下拉动作
- onReachBottom:⻚⾯上拉触底事件的处理函数
- onShareAppMessage:⽤户点击右上⻆转发
- onPageScroll:⻚⾯滚动触发事件的处理函数
- onResize:⻚⾯尺⼨改变时触发，详⻅ 响应显示区域变化
- onTabItemTap:当前是 tab ⻚时，点击 tab 时触发

### 10、请简述小程序路由跳转哪几种
- wx.navigateTo （有返回键，不可以跳转到tabBar页面）
- wx.redirectTo ( 只可以跳转tabBar页面，没有返回，但有首页按钮)
- wx.switchTab （没有返回键，只能跳转到tabBar页面，不可以携带参数）
- wx.navigateBack (应用在目标页面，delta值为1、表示跳转上一页，2、表示跳转两级)
- wx.reLaunch (跳转任意页面，没有返回，有首页按钮)

### 11、⼩程序授权登录流程
- 登陆只需发送code到后台，后台获取openid，根据openid到数据库中查找用户信息，若有则返回用户信息，若没有 将该openid插入数据库。
- 后台生成token，返回前台token，和用户信息
- 前台判断用户信息是否包含用户名称，用户城市等信息，若包含则登陆成功
- 若不包含，则调用 wx.getUserProfile，发送encryptedData，iv，token到后台，后台根据token找到用户openid解密encryptedData和iv获取用户其他信息
- 然后更新数据库，并返回用户信息

### 12、那些方法来提高微信小程序的应用速度？
- 提高页面的加载速度
- 用户行为预测
- 减少默认的data的大小
- 组件化方案
- 压缩静态⽂件，使⽤精灵图，路由分包

### 13、如何分包加载？分包加载的优势在哪？
- 举例：创建多个文件夹，每个文件夹内存放不同的文件，比如创建 packageA、packageB、pages文件夹。 在他们下面可以设置其他文件夹，他们可以设置root路径name名字。一般来说pages为主包
- 优势：单包不大于2M，整体不大于16M，微信限制了代码包不能超过2MB限制了小程序功能的扩展，小程序业务的发展可能需要更大的体积。 于是就有一种方法可以解决那就是分包，分包后整个小程序可以达到8MB，提升了加载速度，减少内存。
- 原理：在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会 把对应分包下载下来，下载完成后再进行展示。

### 14.分析微信小程序的优劣势
- 优势：

  - 容易上手，基础组件库比较全，基本不需要考虑兼容问题
  - 开发文档比较完善，开发社区比较活跃，支持插件式开发
  - 良好的用户体验，无需下载，通过搜索和扫一扫就可以打开，打开速度快，安卓上可以添加到桌面，与原生APP差不多
  - 开发成本比APP要低
  - 为用户提供良好的保障（小程序发布，严格是审查流程）
- 劣势：

  - 限制较多，页面大小不能超过1M，不能打开超过5个层级的页面
  - 样式单一，部分组件已经是成型的，样式不可修改，例如：幻灯片，导航
  - 推广面窄，不能分享朋友圈，只能通过分享给朋友，附加小程序推广
  - 依托与微信，无法开发后台管理功能
  - 后台调试麻烦，因为api接口必须https请求且公网地址
  - 真机测试，个别安卓和苹果表现迥异，例如安卓的定位功能加载很慢

### 15、微信小程序如何实现下拉刷新？
1. 方案一
- 用view代替scroll-view，设置onPullDownRefresh函数实现
2. 方案二
- 通过在 app.json 中， 将 "enablePullDownRefresh": true, 开启全局下拉刷新。
- 或者通过在 组件 .json ， 将 "enablePullDownRefresh": true, 单组件下拉刷新。
### 16、bindtap和catchtap的区别？
- bind事件绑定不会阻止冒泡事件向上冒泡
- catch事件绑定可以阻止冒泡事件向上冒泡

### 17、小程序如何嵌套H5，如何传参？
```
<web-view src="{{url}}"></web-view>

/**
  * 页面的初始数据
  */
data: {
    url: 'www.baidu.com',
},

传参通过路由拼接参数传递
例如：www.baidu.com?id=1&name=xiaoming

```
### 18.使用webview直接加载要注意那些事项？
- 必须要在小程序后台使用管理员添加业务域名
- h5页面跳转至小程序的脚步必须是1.3.1以上
- 微信分享只可以是小程序的主名称，如要自定义分享内容，需小程序版本在1.7.1以上
- h5的支付不可以是微信公众号的appid，必须是小程序的appid，而且用户的openid也必须是用户和小程序的

### 19、webview中的页面怎么跳转回小程序？
```
案例
<script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.3.0.js"></script>
//然后为你的按钮标签注册一个点击事件
$(".kaiqi").click(function(){
        wx.miniProgram.redirectTo({url: '/pages/indexTwo/indexTwo'})
});

//跳转到小程序某个页面
wx.miniProgram.navigateTo({
    url:'pages/login/login'+'$params'
})
//跳转到小程序导航页面
wx.miniProgram.switchTab({
    url:'/pages/index/index'
})
```
### 20、小程序关联微信公众号如何确定用户的唯一性？
- 使用wx.getUserlnfo方法 withCredentials为true时，可获取encryptedData，里面有union_id，后端需要进行对称解密

### 21、小程序支付如何实现？
- 小程序注册，要以公司的身份去注册一个小程序，才有微信支付权限
- 绑定商户号
- 在小程序填写合法域
- 调用wx.login()获取appid
- 调用
```
//后台都会配好返回相对应参数
wx.requestPayment({
  'timeStamp': '',//时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间
  'nonceStr': '',//随机字符串，长度为32个字符以下。
  'package': '',//统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*
  'signType': 'MD5',//签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致
  'paySign': '',//签名,具体签名方案参见微信公众号支付帮助文档;
  'success':function(res){},//成功回调
  'fail':function(res){},//失败
  'complete':function(res){}//接口调用结束的回调函数（调用成功、失败都会执行）
})
```
![支付流程](https://img-blog.csdnimg.cn/20191023094517241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA1ODcyNQ==,size_16,color_FFFFFF,t_70)

### 22、小程序如何获取用户手机号
- 点击获取手机号按钮触发事件
- 判断用户登录状态是否过期，没有过期直接获取用户手机号
- 如果用户登录状态过期，提示用户重新登录，再获取手机号
```
  <button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber">获取手机号</button>

  /**
  * 获取用户微信手机号
  */
  getPhoneNumber (e) {
    let that = this,
      encryptedData = e.detail.encryptedData,
      iv = e.detail.iv;
    that.setData({
      encryptedData: encryptedData,
      iv: iv
    },()=>{
      // 检查登录态是否过期
      wx.checkSession({
        success(res) {
          that.getUserPhone();
        },
        fail(err) {
          // session_key 已经失效，需要重新执行登录流程
          wx.login({
            success: data => {
              Request.getUserOpenId({ data: { code: data.code } }).then(res => {
                if (res.error_code === 0) {
                  wx.setStorageSync('userToken', res.token);
                  resolve(res.token)
                } else {
                  resolve(0)
                }
              }).catch(err => {
                resolve(0)
              })
            }
          })
        }
      }) 
    })
  },

  /**
  * 返回手机号
  */
  getUserPhone(){
    const that = this;
    let params = {
      data: {
        encryptedData: that.data.encryptedData,
        iv: that.data.iv,
        user_id: null,
        token: wx.getStorageSync('userToken')
      }
    }
    Request.getUserPhone(params).then(res => {
      if(res.error_code == 200){
        cache.put(cache.ISTEL, false, -1);
        console.log('用户手机号',res)
      }
    })
  },
```

### 23、小程序开发中遇到那些问题？
- wx.navigateTo⽆法打开⻚⾯ ⼀个应⽤同时只能打开5个⻚⾯，请避免多层级的交互⽅式，或使⽤wx.redirectTo
- tabBar设置不显示tabBar的数量少于2项或超过5项都不会显示
- 本地资源无法通过wxss获取：background-image：可以使用网络图片，或者base64，或者使用标签
- 数据的大小限制，超过范围会直接导致整个小程序崩溃，除非重启小程序
- 小程序不可以直接渲染文章内容这类型的html文本，显示需要借助插件

### 24、本地存储的几种方式
1. wx.setStorageSync(); 用于存储
2. wx.removeStorageSync(); 删除指定的值
3. wx.getStorageSync(); 获取值
4. wx.getStorageInfoSync(); 获取当前存储中所有的 key
5. wx.clearStorageSync(); 清除所有的key

- 以上都是同步的存储，异步存储和同步存储方法一样，在这里就大致列举一下
1. wx.setStorage(); //存储值
2. wx.removeStorage(); // 移除指定的值
3. wx.getStorage(); // 获取值
4. wx.getStorageInfo(); // 获取当前 storage 中所有的 key
5. wx.clearStorage(); // 清除所有的key



